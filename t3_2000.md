---
title: 'T3_2000 Projektarbeit 2'
bibliography: [/tex/t3-2000_2.bib]
author:
  - Jenusan Baskaran
---


# Vorwort 

Diese Projektarbeit, welche im Rahmen des Dualen Studiums an der DHBW Mannheim im Studiengang Informationstechnik mit Schwerpunkt Cybersecurity enstanden ist, behandelt die 3. und 4. Praxisphase, in der ich in zwei verschiedenen Abteilungen meiner Firma Atos Information Technology GmbH arbeiten durfte.

Zunächst habe ich in der 3. Praxisphase, die sich über den 03.01.2022 - 01.04.2022 erstreckt, die Aufgabe bekommen eine hybrid Cloud Lösung in das betriebsinterne Automatisierungsnetzwerk für AWS zu integrieren.

In der 4.Praxisphase, die sich über den 04.07.2022 - 30.09.2022 erstreckt, erhielten wir als ein Projektteam die Aufgabe den Feedbackprozess für Duale Studenten in ihrer Abteilung zu automatisieren. 

Über beide Praxisphasen durfte ich die Aufgaben zum Großteil eigenständig aber auch mit Unterstützung von meinen zuständigen Betreuern und Arbeitskollegen bearbeiten.



# Praxisphase 3

## Motivation

Um meine Programmierfähigkeiten zu verbessern und mich mit weiter mit Themenumfeld der Cloud vertraut zu machen, habe ich mit dazu entschieden eine weitere Praxisphase in der CES OP SaaS Abteilung zu machen. In der 2. Praxisphase entwickelte ich bereits Powershellskripten, welche die Katalogisierung von Amazon Web Services Cloud Resourcen in einem Datenbanksystem für die Atos Cloud Plattform (ACP) automatisieren.
Basierend darauf lag dieses mal meine Aufgabe dabei Powershell-Skripte zu schreiben, welche nach der Ausführung, Public Cloud Resourcen zur Verfügung stellt.


## Problemstellung

Die Skripte sollen in das Betriebsinterne Automatisierungsnetzwerk, die ACP, integriert werden, um die Resourcen für Kunden, welche die ACP nutzen, zu verwalten, in einer Datenbank zu katalogisieren und zu überwachen. Über die ACP können dann nach Fertigstellung der Lösung die AWS-Umgebungen mehrerer Kunden verwaltet werden.


![Roadmap zu meiner Aufgabenstellung](Roadmap.png){#fig:Roadmap}

In dieser Roadmap ist die Aufgabenverteilung zwischen meinem Kollegen und mir zu sehen. Während mein erfahrenerer Kollege Ralf sich um die Implentierung von Scripts für mehreren Arten von AWS-Resourcen gekümmert hat, habe ich mich hauptsächlich auf die Ausarbeitung von Scripts für die Bereitstellung von Application Load Balancern konzentriert.

## Grundlagen

### Verwendetete Tools und Programme

In diesem Abschnitt sollen Grundlagen wie verwendete Technologien und deren Vor- und Nachteile, Lösungsverfahren und weitere relevante Themen im Kontext der 3. Praxisphase erläutert werden.



#### CloudFormation

Um ein besseres Verständnis von der Funktionsweise der ACP zu bekommen, habe ich als ersten Schritt einen Kurs zu AWS CloudFormation bearbeitet. Dieser Kurs deckt alle wichtigen Grundlagen und Konzepte ab, auf welche die Cloud Plattform basiert.

Lernziele dieses Kurses sind:

- Benutzung von AWS CloudFormation für die Provision und Management von Enterprise Level Infrastrukturen
- Verständnis des Infrastructure as Code Modells (gekürzt IaC)
- Continuous Delivery mit Code Pipeline
- Erstellen von Pipeline Tests & Production Stacks mit Templates
- CloudFormation Sicherheits Funktionen mit der Verwendung von CloudTrail
- Funktionen der AWS CloudFormation

Ich werde aber nur die Konzepte in dieser Arbeit erläutern, welche relevant für das Verständnis der Cloud Plattform und meinem Aufgabenbereich sind, es fallen somit die letzten beiden Punkte teilweise bzw. ganz aus, da ich zum einen nicht für die Sicherheitsaspekte verantwortlich gewesen bin und zum anderen nicht direkt AWS Cloudformation verwendet wird.


#### Infrastructure as Code (IaC)

Definition: Mit IaC (Infrastructure as Code) wird die Infrastruktur durch Code – und nicht durch manuelle Prozesse – verwaltet und provisioniert.

Es werden Konfigurationsdateien erstellt, welche die gesamten Infrastrukturspezifikationen enthalten, wodurch Konfigurationen einfacher bearbeitet und verteilt werden können. Es stellt außerdem sicher, dass jedes Mal dieselbe Umgebung provisioniert wird. 
Indem Konfigurationsspezifikationen kodifiziert und dokumentiert werden, unterstützt IaC das Konfigurationsmanagement und hilft, undokumentierte Ad-hoc-Änderungen der Konfiguration zu vermeiden. Ein wichtiger Bestandteil von IaC ist die Versionskontrolle. Wie jede andere Software-Quellcodedatei sollten auch Konfigurationsdateien der Quellkontrolle unterliegen. Durch die Bereitstellung der Infrastruktur als Code kann die Infrastruktur auch in modulare Komponenten aufgeteilt und dann durch Automatisierung auf unterschiedliche Weise kombiniert werden können. Durch eine automatisierte Infrastrukturprovisionierung mit IaC müssen Server, Betriebssysteme, Storage und andere Infrastrukturkomponenten von den Entwicklerinnen und Entwicklern nicht jedes Mal, wenn diese eine Anwendung entwickeln oder bereitstellen, manuell provisioniert und verwaltet werden. Durch die Codierung der Infrastruktur entsteht eine Vorlage, der bei der Provisionierung gefolgt werden kann. Die Atos Cloud Plattform dient unter anderem als IaC-Plattform. [@WasIstIaC]


#### Risiken in Verbindung mit IaC:

IaC ist nur effektiv für Prozesse, die bereits auf Automatisierung ausgerichtet sind. Es werden viele zusätzliche Tools benötigt für z.B. Legacy Monitoring und Security Tools. Zudem muss man auch auf die Problematik von Konfigurationsverschiebungen achten, also auf Veränderung welche ausserhalb des IaC-Prozesses gemacht wurden. Beispielsweise, wenn ein IT-Admin in das System geht und die Konfigurationen ändert. Es sind zusätzliches Trainings für Entwickler und gesondert verwaltete Zugriffsrechte erforderlich. Zusätzliche Verantwortlichkeiten für die Entwickler wie Beachtung der Systemkonfiguration sowie sichere Veränderungen der Konfigurationen müssen auch berücksichtigt werden.


#### IaC Cloud Automatisierung:

IaC Cloud Automation basiert auf den Prinzipien der Abstraktion von physischer Hardware von der Bereitstellung der Infrastruktur, darüberhinaus soll sie auch von der manuellen Intervention getrennt werden, was zu Prozessautomatisierung führt. Die virtuellen Resourcen werden dann mithilfe von Software beschrieben. Die Konfiguration von VM oder ähnliche Instanzen, die Arbeitslastkontrolle, Serviceverbindung und Deployment Monitoring/Management fallen ebenfalls in die IaC Cloud Automation.


#### CloudFormation Management:

Das Managen von Resourcen erfolgt mit den Templates. Die Details der Resourcendefinitionen können in einem Stack modifiziert werden.
Die Wiederverwendbarkeit der Templates machen sich z.B bei der Bereitstellung derselben Resourcen in verschiedenen Regionen sehr nützlich.
Parameter erlauben die Anpassung von Templates, während der Bereitstellung,wenn beispielsweise nur in bestimmten Regionen Resources erstellt werden sollen.
Mappings sind Key value pairs, wo der Key ein String ist und der Value ein String oder eine Liste ist. Sie können als Variable in der Ressourcedefinition verwendet werden, indem ein intrinsischer Funktionsaufruf verwendet wird. Es werden Bestimmte Schlüssel und entsprechende Werte in der Bereitstellung verwendet, zusammen mit Bedingungen erlauben sie Logik im Template und ermöglichen die Verwendung von dynamischen Werten. Templates bilden somit ausgeklügelte logikbasierte Verwaltung von Ressourcen.


#### Continuous Delivery mit AWS Code Pipeline:

Die Continuous Delivery Code Pipeline ist eine beliebte Release Methode für die Automatisierung der Package Delivery und bringt eine schnelle und konsistente Verwaltung von Code, Code Review und Code Deployment.


Jede Pipeline enthält eine Deployment Aktion (hinzufügen einer Deployment Aktion, Auswählen eines Providers), welche die CodePipeline-Aktionen spezifizieren:

- Erstellen oder aktualisieren eines Stacks
- Zuordnung des Modus
- Stack Name
- Template
- Template Konfiguration
- Einige Resourcen brauchen eine Verifikation, bevor sie geändert werden

Beispiel eines grundlegendes CodePipeline-Templates mit allen wichtigen Komponenten im YAML-Format:

```{.basic-pipeline .numberLines startFrom=0}

# THIS TEMPLATE IS FROM THE "AWS Developer Associate 2021: CloudFormation" 
PERCIPIO/SkillSoft COURSE OF BILL BROOKS

AWSTemplateFormatVersion: "2010-09-09"

Description: >
  This creates a demo pipeline that deploys a test 
  and production version of an s3 bucket.

# start of parameters: inputs for template
Parameters:
  PipelineName:
    Type: String
  S3Bucket:                     
  # source of YAML template
    Default: demo-s3
    Type: String
  SourceS3Key:                  
  # If Key file is changed, pipeline will run
    Default: demo-s3.zip        
	# Everytime .zip changes, pipeline will re-run
    Type: String
  Template:                     
    Default: demo-s3.yaml
    Type: String

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: "CodePipeline Settings"
        Parameters:
          - PipelineName
          - S3Bucket
          - SourceS3Key
      - Label:
          default: "Stack Settings"
        Parameters:
          - Template

Resources:
  ArtifactStoreBucket:          
    Type: AWS::S3::Bucket
	#is used by pipeline to load yaml that it deploys 
    Properties:
      VersioningConfiguration:
        Status: Enabled

  Pipeline:
    Type: AWS::CodePipeline::Pipeline
    Properties:
      ArtifactStore:
        Location: !Ref 'ArtifactStoreBucket'
        Type: S3
      DisableInboundStageTransitions: []
      Name: !Ref 'PipelineName'
      RoleArn: !GetAtt [PipelineRole, Arn] # load artifact
      Stages
      .
      .
      .
```

Eine ähnliche Codepipeline wird auch in der ACP verwendet, um die Delivery von Code an die jeweiligen Deployment-Server zu verwalten, jedoch nicht über den AWS-spezifischen CodePipeline Service und verwendet statt YAML ein JSON Format, wobei jedoch der grundlegende Aufbau ähnlich bleibt. 


#### AWS Loadbalancer

Im Folgenden wird die Funktionsweise eines AWS Loadbalancers, zusammen mit seinen notwendigen Komponenten beschrieben.

"Ein Load Balancer nimmt eingehenden Datenverkehr von Clients entgegen und leitet Anfragen an seine registrierten Targets (z. B. EC2-Instanzen \footnote{Elastic Cloud Computing: VMs, welche mit unterschiedlichen Rechenleistungen, RAM, etc. konfiguriert werden können.} ) in einer oder mehreren Availability Zones weiter. Der Load Balancer überwacht auch den Zustand seiner registrierten Targets und stellt sicher, dass er über Health- Checks den Datenverkehr nur an gesunde Targets weiterleitet. Wenn der Load Balancer ein ungesundes Target feststellt, stoppt er das Routing des Datenverkehrs zu diesem Target. Er nimmt die Weiterleitung des Datenverkehrs zu diesem Target wieder auf, wenn er feststellt, dass das Target wieder in Ordnung ist. Ein Load Balancer wird für die Annahme von eingehendem Datenverkehr konfiguriert, indem ein oder mehrere Listener angegeben wird. Ein Listener ist ein Prozess, der auf Verbindungsanfragen prüft. Er wird mit einem Protokoll und einer Portnummer für Verbindungen von Clients zum Load Balancer konfiguriert. Ebenso wird er mit einem Protokoll und einer Portnummer für Verbindungen vom Load Balancer zu den Targets konfiguriert. 

Elastic Load Balancing unterstützt die folgenden Arten von Load Balancern:

- Application Load Balancer (ALB)
- Network Load Balancer (NLB)
- Gateway Load Balancer (GLB)
- Classic Load Balancer (ClassicLB)

Ein wesentlicher Unterschied besteht darin, wie die Load Balancer-Typen konfiguriert werden. Bei Application Load Balancers, Network Load Balancers und Gateway Load Balancers werden Ziele in Target Groups registriert und leiten den Verkehr zu den Target Groups. Bei klassischen Load Balancern registriert man Instanzen direkt beim Load Balancer." [@HowElasticLoad] 

Funktionsweise der Application Load Balancer: 

"Ein Load Balancer dient als zentrale Anlaufstelle für Clients. Der Load Balancer verteilt den eingehenden Anwendungsverkehr auf mehrere Targets, wie z. B. EC2-Instanzen(VMs), in mehreren Availability Zones. Dadurch wird die Verfügbarkeit einer Anwendung erhöht. Man fügt einen oder mehrere Listener zu einem Load Balancer hinzu. 

Ein Listener prüft auf Verbindungsanfragen von Clients unter Verwendung des konfigurierten Protokolls und Ports. Die Regeln, die für einen Listener definiert, bestimmen, wie der Load Balancer Anfragen an seine registrierten Targets weiterleitet. Jede Regel besteht aus einer Priorität, einer oder mehreren Aktionen und einer oder mehreren Bedingungen. Wenn die Bedingungen für eine Regel erfüllt sind, werden die entsprechenden Aktionen ausgeführt. Man muss für jeden Listener eine Standardregel definieren und es können optional zusätzliche Regeln definiert werden. 

Jede Target Group leitet Anfragen an ein oder mehrere registrierte Targets weiter, z. B. an EC2-Instanzen, und verwendet dabei das (HTTP)-Protokoll und die Portnummer, die gewünscht sind. Ein Target kann bei mehreren Target Groups registrieren. Es können Zustandsprüfungen für jede Target Group konfiguriert werden. 

Das folgende Diagramm veranschaulicht die grundlegenden Komponenten. Es muss beachtet werden, dass jeder Listener eine Standardregel enthält und weitere Regeln enthalten kann, die Anfragen an eine andere Target Group weiterleitet. Laut den Best Practices soll ein Target mindestens bei zwei Target Groups registriert werden aufgrund von Redundanz und Verfügbarkeit." [@WhatApplicationLoad] 


![Modell zur Funktionsweise der Application Loadbalancer in AWS](component_architecture.png){#fig:ALB}

#### AWS Cloud: Begriffsdefinitionen

Im Folgenden werden einige wichtige Begriffe im Kontext der AWS Public Cloud erklärt, um den Code der Powershell-Skripts verständlicher zu machen.

- VPC (Virtual Private Cloud):  Eine VPC ist ein virtuelles Netzwerk, das einem herkömmlichen Netzwerk, das in eigenen Rechenzentrum betreiben wird, sehr ähnlich ist. Nachdem eine VPC erstellt ist, können Subnetze hinzugefügt.[@WasIstAmazon]
- Subnet: Ein Subnet ist ein Bereich an IP-Adressen in Ihrer VPC. Ein Subnet muss sich in einer einzigen Availability Zone befinden. Nachdem die Subnetze hinzugefügt wurden, können AWS-Ressourcen in der VPC bereitgestellt werden. [@WasIstAmazon]
- Security Group: Eine Sicherheitsgruppe steuert den Datenverkehr, der die Ressourcen erreichen und verlassen darf, mit denen er verknüpft ist. Nachdem beispielsweise eine Sicherheitsgruppe mit einer EC2-Instance verknüpft wird, steuert sie den ein- und ausgehenden Datenverkehr für die Instance.
Wenn eine VPC erstellt wird, verfügt diese über eine Standardsicherheitsgruppe. Es können für jede VPC auch zusätzliche Sicherheitsgruppen erstellt werden. Es können Sicherheitsgruppen nur Ressourcen in der VPC zugeordten werden, für die sie erstellt wurden. [@SteuernSieDatenverkehr]

## Ausarbeitung - Powershell Skripte

### Powershell-Scripts für die Bereitstellung der ALB

Da das Erklären aller Skripte, die ich erstellt habe, nicht mehr im Rahmen der Projektarbeit wäre, werde ich beispielhaft für alle Skripte, im folgenden Abschnitt den Code für das Deployment eines Loadbalancers zusammem mit seinen zugehörigen Komponenten erklären. Die Skripte werden über eine Codepipeline auf einem Deployment-Server transferiert und dann über diesen in der Powershell ausgeführt, wenn er eine Anfrage über das ACP-Interface erhält.


```{.Atos.Cloud.AWS.Loadbalancer.Create.ps1 .numberLines startFrom=1}
<#
.SYNOPSIS
.DESCRIPTION
    Please read the full Description first before using this PS script file.
    This script is able to create new Elastic LoadBalancer (ELB) 
    as an Application LoadBalancers (ALB)
	together with TargetGroups and Listeners.
	Features:
		- JSON input parameters
			- Requires following input parameters
				- LoadBalancers:
					- Name (optional, see below) [string]
					- two subnets in two different Availability Zones [string]
					- Tags [Key:"Name"; Value:string] (For Naming)
					- all other parameters are automatically set to
          default values but can be overridden if necessary
				- TargetGroups:
					- Name (optional, see below)
					- VpcId [string]
					- Port [int32]
					- Tags [Key:"Name"; Value:string] (For Naming)
					- all other parameters are automatically set to
          default values but can be overridden if necessary
				- Listeners:
					- DefaultAction [string]
					- Port [int32]
					- Protocol [string]
		- Automatically generate or specify names for ALBs and TGs 
		- Create ALBs
		- Create TargetGroups
			- Custom HealthChecks possible
			- Currently only viable with HTTP Protocol
			- Currently only viable with TargetType "Instance"
		-Create Listeners
			- Currently only viable with DefaultAction "forward"
			- Currently only viable with HTTP Protocol
		-Tagging for LoadBalancer and TargetGroup
		-Enables deployment of full LoadBalancer enviroment and
    registration of LBs to TargetGroups via Listener
    if configuration is adequate
	Future Implementation plans:
		- Add support for HTTPS protocol to offload encryption workload 
    from applications/instances
			- Add support for Certificate processing
		- Inventory
		- Add support for Network and Gateway LBs
		- Add Error Handling
	-> Sources:	<siehe Code-Erklärung>
.EXAMPLE
.NOTES
    File Name      : Atos.Cloud.AWS.Loadbalancer.Create
    Author         : Jenusan Baskaran
    Prerequisite   : PowerShell 5.1
    Version        : 20220322
#>

```

Jedes Skript enthält eine prägnante Beschreibung, in welcher die benötigten Parameter angegeben sind. Es werden auch die Funktionen des Skripts, also was genau provisioniert (oder bei den anderen Skripts verändert) werden kann und geplante Funktionen beschrieben. Zudem werden auch die Quellen , die für die Erstellung des Skripts verwendet wurden, angegeben.

```{.Atos.Cloud.AWS.Loadbalancer.Create.ps1 .numberLines startFrom=1}
Process{
    $startTime = Get-Date
	
	$fullConfig = Get-Content 
  "C:\Users\jenujenujenu\Documents\PS_Scripts_AWS\
  AWS_Actions_Git\AWS Basic Automation\examples\input\
  LoadBalancer\ParameterJSON_min_LB.json"

	#Import-Module AWSPowerShell
    #$ServiceProfile "acpauto"
    
    #Set-AWSCredential -ProfileName $ServiceProfile


	if ($fullConfig) {
		$Config = [PSObject] ($fullConfig | ConvertFrom-Json)
		$LBcount = $Config.LoadBalancers.length #LB counter
	} else {
		$LBcount = 1
	}
	"$LBcount LoadBalancer to deploy"

	# Loop through LB Array from JSON input to fetch parameters
	for ($i=0; $i -lt $LBcount; $i++){

		if ($fullConfig) {
			if($null -ne $Config.Customer){
				$Customer = $Config.Customer
			}
			if ($null -ne $Config.Loadbalancers[$i].Location) {
				$Region = $Config.Loadbalancers[$i].Location
			}
			if ($null -ne $Config.LoadBalancers[$i].LBName) {
				$LBName = $Config.LoadBalancers[$i].LBName
			}
			if ($null -ne $Config.LoadBalancers[$i].IpAddressType) {
				$IpAddressType = $Config.LoadBalancers[$i].IpAddressType
			}
            if ($null -ne $Config.LoadBalancers[$i].LBType) {
				$LBType = $Config.LoadBalancers[$i].LBType
			}
			if ($null -ne $Config.LoadBalancers[$i].Scheme) {
				$Scheme = $Config.LoadBalancers[$i].Scheme
			}
			if ($null -ne $Config.LoadBalancers[$i].Networkadapters[0].Subnet) {
				$Subnet = $Config.LoadBalancers[$i].Networkadapters[0].Subnet
			}
			if ($null -ne $Config.LoadBalancers[$i].Networkadapters[0].SecurityGroups) {
				$SecurityGroup = $Config.LoadBalancers[$i].Networkadapters[0].SecurityGroups
			}
			if ($null -ne $Config.LoadBalancers[$i].Tags) {
				$tagobject = $Config.LoadBalancers[$i].Tags
			}
		}
		#Generate Name if for LB if it is not defined already
		if ($null -eq $LBName) {
			$LBName = "LB" +  (Get-Date -format yyyyMMddHHmmss) + $i
		}
```

Der Deploymentprozess startet mit dem Auslesen der benötigten Parameter aus der $fullconfig JSON Datei, welche über ein GUI in der ACP erstellt wird. Für die Ausführung des Deployments werden zusätzliche AWS-spezifische Cmdlets benötigt, die über das Import-Module Statement installiert werden. Die AWS Credentials zur Authentifizierung werden über das Set-AWSCredential Statement gesetzt und sind in Umgebungsvariabel gesichert. Die Anzahl der Loadbalancer, die in der JSON Datei definiert sind, werden mit dem $LBcount Parameter ermittelt. Anschließend wird ein Loop gestartet, der für jeden Loadbalancer die benötigten Parameter ausliest und in die entsprechenden Variablen schreibt. Der Loop endet erst dann, wenn alle Loadbalancer und ihre zugehörigen Komponenten, deren Anzahl ebenfalls aus der $fullconfig JSON ausgelesen und in einem Loop innerhalb der Loadbalancer-Schleife verarbeitet und bereitgestellt werden. Falls ein Parameter nicht definiert ist, wird er mit einem Default-Wert belegt, welcher von AWS festgelegt ist. Die Parameter werden in der Konsole ausgegeben, um die korrekte Ausführung zu überprüfen. 

```{.Atos.Cloud.AWS.Loadbalancer.Create.ps1 .numberLines startFrom=1}

		#Add tags to LB
		if ($tagobject) {
			foreach ($element in $tagobject) {
				#$element = $element.Replace(" ","-") # don't allow spaces in tags
				"Add tag " + $element.Key + " -> " + $element.Value
				$LBtag= @{ Key=$element.Key; Value=$element.Value}
			}
		}
		$CustomerTag= @{ Key="Customer"; Value=$Customer}
		
		New-ELB2LoadBalancer 
        -Name $LBName 
        -IpAddressType $IpAddressType 
        -Scheme $Scheme 
        -Subnet $Subnet 
        -Type $LBType 
        -ProfileName $ServiceProfile 
        -Region $Region 
        -SecurityGroup $SecurityGroup 
        -Tag $LBtag,$CustomerTag

		$ELB2LBObj = Get-ELB2LoadBalancer -Name $LBName -Region $Region

		#Add LB to Object Array
		$ELB2LBObjArr= @()
		$ELB2LBObjArr+= $ELB2LBObj
		$LoadBalancerArn = $ELB2LBObj[$i].LoadBalancerArn #needed to get ARN for Listeners

		$endTime= Get-Date
		$msg = 'Provisioning of the LoadBalancer {0} with type of {1} 
        for customer {2} has been completed with 
        start time {3} and end time {4}' 
        -f $LBName, $LBType, $Customer, $startTime, $endTime

		Write-Output $msg
```

Es können auch Tags für den Loadbalancer zu Zwecken der Namensgebung und Organisation vergeben werden, sie sind aber nicht zwingend notwendig. Anschließend darauf wird der Loadbalancer mit dem New-ELB2LoadBalancer Cmdlet erstellt und provisioniert. Danach wird der Loadbalancer abgefragt und in der $ELB2LBObj Variable gespeichert, um die ARN (Amazon Resource Name) zu erhalten, welche benötigt wird, wenn man beispielsweise alle Listener auflisten möchte, die an einem Loadbalancer verbunden sind.

```{.Atos.Cloud.AWS.Loadbalancer.Create.ps1 .numberLines startFrom=1 }

		#Create TargetGroups
		$startTime = Get-Date

		if ($fullConfig) {
			$TGcount = $Config.LoadBalancers[$i].TargetGroups.length
		} else {
			$TGcount = 1
		}
		"$TGcount TargetGroups to deploy"

		#Loop through TG Array from JSON input to fetch parameters
    	for ($j=0; $j -lt $TGcount; $j++){

			if ($fullConfig) 
			{
				if ($null -ne $Config.LoadBalancers[$i].TargetGroups[$j].TGName) {
        	        $TGName = $Config.LoadBalancers[$i].TargetGroups[$j].TGName
        	    }
        	    if ($null -ne $Config.LoadBalancers[$i].TargetGroups[$j].Port) {
        	        $TGPort = $Config.LoadBalancers[$i].TargetGroups[$j].Port
        	    }
				if ($null -ne $Config.LoadBalancers[$i].TargetGroups[$j].Protocol) {
            		$TGProtocol = $Config.LoadBalancers[$i].TargetGroups[$j].Protocol
       		    }
				if ($null -ne $Config.LoadBalancers[$i].TargetGroups[$j]
                .ProtocolVersion) {
         	    	$TGProtocolVersion =
                    $Config.LoadBalancers[$i].TargetGroups[$j].ProtocolVersion
            	}
				if ($null -ne $Config.LoadBalancers[$i].TargetGroups[$j]
                .TargetType) {
                	$TargetType = 
                    $Config.LoadBalancers[$i].TargetGroups[$j].TargetType
            	}
            	if ($null -ne $Config.LoadBalancers[$i].TargetGroups[$j].NetworkAdapters
                .VpcId) {
                	$VpcId = 
                    $Config.LoadBalancers[$i].TargetGroups[$j].NetworkAdapters.VpcId
            	}
            	if ($null -ne $Config.LoadBalancers[$i].TargetGroups[$j]
                .HealthCheckEnabled) {
                	$HealthCheckEnabled = 
                    $Config.LoadBalancers[$i].TargetGroups[$j].HealthCheckEnabled
            	}
            	if ($null -ne $Config.LoadBalancers[$i].TargetGroups[$j]
                .HealthCheckIntervalSecond) {
                	$HealthCheckIntervalSecond = 
                    $Config.LoadBalancers[$i].TargetGroups[$j].HealthCheckIntervalSecond
            	}
            	if ($null -ne $Config.LoadBalancers[$i].TargetGroups[$j]
                .HealthCheckPath) {
                	$HealthCheckPath = 
                    $Config.LoadBalancers[$i].TargetGroups[$j].HealthCheckPath
            	}
            	if ($null -ne $Config.LoadBalancers[$i].TargetGroups[$j]
                .HealthCheckPort) {
                	$HealthCheckPort = 
                    $Config.LoadBalancers[$i].TargetGroups[$j].HealthCheckPorts
            	}
            	if ($null -ne $Config.LoadBalancers[$i].TargetGroups[$j]
                .HealthCheckProtocol) {
                	$HealthCheckProtocol = 
                    $Config.LoadBalancers[$i].TargetGroups[$j].HealthCheckProtocol
            	}
            	if ($null -ne $Config.LoadBalancers[$i].TargetGroups[$j]
                .HealthCheckTimeoutSecond) {
                	$HealthCheckTimeoutSecond = 
                    $Config.LoadBalancers[$i].TargetGroups[$j].HealthCheckTimeoutSecond
            	}
            	if ($null -ne $Config.LoadBalancers[$i].TargetGroups[$j]
                .HealthyThresholdCount) {
                	$HealthyThresholdCount = 
                    $Config.LoadBalancers[$i].TargetGroups[$j].HealthyThresholdCount
            	}	
            	if ($null -ne $Config.LoadBalancers[$i].TargetGroups[$j]
                .Matcher_GrpCode) {
                	$Matcher_GrpCode = 
                    $Config.LoadBalancers[$i].TargetGroups[$j].Matcher_GrpCode
            	}	
            	if ($null -ne $Config.LoadBalancers[$i].TargetGroups[$j]
                .Matcher_HttpCode) {
                	$Matcher_HttpCode = 
                    $Config.LoadBalancers[$i].TargetGroups[$j].Matcher_HttpCode
            	}
            	if ($null -ne $Config.LoadBalancers[$i].TargetGroups[$j]
                .UnhealthyThresholdCount) {
                	$UnhealthyThresholdCount = 
                    $Config.LoadBalancers[$i].TargetGroups[$j].UnhealthyThresholdCount
            	}
				if ($null -ne $Config.LoadBalancers[$i].TargetGroups[$j].Tags) {
					$tagobject = 
                    $Config.LoadBalancers[$i].TargetGroups[$j].Tags
				}
        	}
    
		#Generate Name for TG if it is not defined already
		if ($null -eq $TGName) {
			$TGName = "TG" +  (Get-Date -format yyyyMMddHHmmss) + $j
		}

		#Add Tags for TG
		if ($tagobject) {
			foreach ($element in $tagobject) {
				#$element = $element.Replace(" ","-") # don't allow spaces in tags
				"Add tag " + $element.Key + " -> " + $element.Value
				$TGtag= @{ Key=$element.Key; Value=$element.Value}	
			}
		}

		New-ELB2TargetGroup -Region $Region -Name $TGName -Port $TGPort 
        -Protocol $TGProtocol -ProtocolVersion $TGProtocolVersion 
        -TargetType $TargetType -VpcId $VpcId 
        -Matcher_GrpcCode $Matcher_GrpCode -HealthCheckEnabled 
        $HealthCheckEnabled -HealthCheckIntervalSecond 
        $HealthCheckIntervalSecond -HealthCheckPath 
        $HealthCheckPath -HealthCheckPort 
        $HealthCheckPort -HealthCheckProtocol 
        $HealthCheckProtocol -HealthCheckTimeoutSecond 
        $HealthCheckTimeoutSecond -HealthyThresholdCount 
        $HealthyThresholdCount -Matcher_HttpCode 
        $Matcher_HttpCode -UnhealthyThresholdCount 
        $UnhealthyThresholdCount -Tag $TGtag, $CustomerTag

		$ELB2TGObj=Get-ELB2TargetGroup -Name $TGName -Region $Region
		
		#Add TG to Object Array
		$ELB2TGObjArr= @()
		$ELB2TGObjArr+= $ELB2TGObj
		#Set TGARN for DefaultAction "forward"
		$TargetGroupArn = $ELB2TGObjArr[$j].TargetGroupArn
	}

```

Ähnlich wie im Loadbalancer Abschnitt werden hier die TargetGroups erstellt. Es wird ein For-Loop, basierend auf der Anzahl der gewünschten Targetgroups, gestartet und die Parameter für die Eigenschaften der TargetGroups ausgelesen und gespeichert. Für die meisten "HealthCheck" Parameter werden oft Default Werte verwendet. Falls kein Name definiert wurde, wird hier ebenfalls ein Name generiert. Anschließend wird die TargetGroup mit dem "New-ELB2TargetGroup" Cmdlet erstellt. Zum Schluss wird die erstellte TargetGroup als Objekt in einem Array gespeichert, damit hier, ähnlich wie bei den LoadBalancern, die ARN ausgelesen werden kann, welche bei der Einrichtung der Listener benötigt wird.


```{.Atos.Cloud.AWS.Loadbalancer.Create.ps1 .numberLines startFrom=1}

	#Create Listeners
	$startTime = Get-Date

	if ($fullConfig) {
		$Config = [PSObject] ($fullConfig | ConvertFrom-Json)
		$LIScount = $Config.LoadBalancers[$i].Listeners.length
	} else {
		$LIScount = 1
	}

    "$LIScount Listeners to create"

	for ($k=0; $k -lt $LIScount; $k++){

		if ($fullConfig) {
            if ($null -ne $Config.Loadbalancers[$i].Listeners[$k].AlpnPolicy) {
                $AlpnPolicy = $Config.Loadbalancers[$i].Listeners[$k].AlpnPolicy
            }
            if ($null -ne $Config.Loadbalancers[$i].Listeners[$k].Certificate) {
                $Certificate = $Config.Loadbalancers[$i].Listeners[$k].Certificate
            }
            if ($null -ne $Config.Loadbalancers[$i].Listeners[$k].DefaultAction){
                $DefaultAction = $Config.Loadbalancers[$i].Listeners[$k].DefaultAction
            }
            if ($null -ne $Config.Loadbalancers[$i].Listeners[$k].Port) {
                $Port = $Config.Loadbalancers[$i].Listeners[$k].Port
            }
            if ($null -ne $Config.Loadbalancers[$i].Listeners[$k].Protocol) {
                $Protocol = $Config.Loadbalancers[$i].Listeners[$k].Protocol
            }
            if ($null -ne $Config.Loadbalancers[$i].Listeners[$k].SslPolicy) {
                $SslPolicy = $Config.Loadbalancers[$i].Listeners[$k].SslPolicy
            }
        }

			switch ($DefaultAction) {
				forward {
					$DefaultActionObject = New-Object Amazon.ElasticLoadBalancingV2
                    .Model.Action
					$DefaultActionObject.ForwardConfig = New-Object Amazon
                    .ElasticLoadBalancingV2.Model.ForwardActionConfig
					$DefaultActionObject.Type =$DefaultAction
					$DefaultActionObject.TargetGroupArn =$TargetGroupArn
				}
				fixed-response{
					$DefaultActionObject = New-Object Amazon
                    .ElasticLoadBalancingV2.Model.Action
					$DefaultActionObject.FixedResponseConfig = New-Object 
                    Amazon.ElasticLoadBalancingV2.Model.FixedResponseActionConfig
					$DefaultActionObject.Type =$DefaultAction
					$DefaultActionObject.FixedResponseConfig.StatusCode = 200
					$DefaultActionObject.FixedResponseConfig.ContentType = 
                    'text/plain'
					$DefaultActionObject.FixedResponseConfig.MessageBody = 
                    'This is a fixed response. Kind of obvious'
				}

				# following DefaultActions not currently working;
                #should be detailed and fully fleshed out in the future
				redirect{
                    $DefaultActionObject = New-Object Amazon
                    .ElasticLoadBalancingV2.Model.Action
                    $DefaultActionObject.RedirectConfig = New-Object 
                    Amazon.ElasticLoadBalancingV2.Model.RedirectActionConfig
                    $DefaultActionObject.Type =$DefaultAction
                    <#
                    $DefaultActionObject.RedirectConfig.Host =
                    $DefaultActionObject.RedirectConfig.Path =
                    $DefaultActionObject.RedirectConfig.Port =
                    $DefaultActionObject.RedirectConfig.Protocol =
                    $DefaultActionObject.RedirectConfig.Query =
                    $DefaultActionObject.RedirectConfig.StatusCode =
                    #>
                }
                authenticate-cognito{
                    $DefaultActionObject = New-Object 
                    Amazon.ElasticLoadBalancingV2.Model.Action
                    $DefaultActionObject.AuthenticateCognitoConfig = 
                    New-Object 
                    Amazon.ElasticLoadBalancingV2.Model
                    .AuthenticateCognitoActionConfig
                    $DefaultActionObject.Type =$DefaultAction
                    <#
                    $DefaultActionObject.AuthenticateCognitoConfig
                    .AuthenticationRequestExtraParams =
                    $DefaultActionObject.AuthenticateCognitoConfig
                    .OnUnauthenticatedRequest =
                    $DefaultActionObject.AuthenticateCognitoConfig
                    .Scope =
                    $DefaultActionObject.AuthenticateCognitoConfig
                    .SessionCookieName =
                    $DefaultActionObject.AuthenticateCognitoConfig
                    .UserPoolArn =
                    $DefaultActionObject.AuthenticateCognitoConfig
                    .UserPoolClientId =
                    $DefaultActionObject.AuthenticateCognitoConfig
                    .UserPoolDomain =
                    #>
                }
                authenticate-oidc{
                    $DefaultActionObject = New-Object 
                    Amazon.ElasticLoadBalancingV2.Model.Action
                    $DefaultActionObject.AuthenticateOidcConfig = 
                    New-Object Amazon.ElasticLoadBalancingV2.Model
                    .AuthenticateOidcActionConfig
                    $DefaultActionObject.Type =$DefaultAction
                    <#
                    $DefaultActionObject.AuthenticateOidcConfig
                    .AuthenticationRequestExtraParams =
                    $DefaultActionObject.AuthenticateOidcConfig
                    .AuthorizationEndpoint =
                    $DefaultActionObject.AuthenticateOidcConfig
                    .ClientId =
                    $DefaultActionObject.AuthenticateOidcConfig
                    .ClientSecret =
                    $DefaultActionObject.AuthenticateOidcConfig
                    .Issuer =
                    $DefaultActionObject.AuthenticateOidcConfig
                    .OnUnauthenticatedRequest =
                    $DefaultActionObject.AuthenticateOidcConfig
                    .Scope =
                    $DefaultActionObject.AuthenticateOidcConfig
                    .SessionCookieName =
                    $DefaultActionObject.AuthenticateOidcConfig
                    .SessionTimeout =
                    $DefaultActionObject.AuthenticateOidcConfig
                    .TokenEndpoint =
                    $DefaultActionObject.AuthenticateOidcConfig
                    .UseExistingClientSecret =
                    $DefaultActionObject.AuthenticateOidcConfig
                    .UserInfoEndpoint =
                    #>
                }
			Default{
			Write-Output 'Cannot resolve DefaultAction input'
				}
			}

		# Create Listener
		New-ELB2Listener -Region $Region 
        -LoadBalancerArn $LoadBalancerArn 
        -DefaultAction $DefaultActionObject 
        -Port $Port 
        -Protocol $Protocol 
        -SslPolicy $SslPolicy 
        -Certificate $CertificateObj

		$endTime = Get-Date

		$msg = 'Creation of Listener for Loadbalancer {0} for customer {1} 
        has been completed with start time {2} and end time {3}' 
        -f $LoadBalancerArn, $Customer, $startTime, $endTime
    	Write-Output $msg
		}
	}
}

```

Zum Ende des "Create" Skripts werden die Listener für die jeweiligen Loadbalancer erstellt. Wie bei den voherigen Abschnitten werden auch hier wieder die Parameter aus der JSON-Datei ausgelesen und in Variablen gespeichert. Anschließend wird ein Switch-Case verwendet, um die verschiedenen DefaultActions zu unterscheiden. Je nach DefaultAction wird ein entsprechendes Objekt erstellt und mit den entsprechenden Parametern befüllt. Anschließend wird das "New-ELB2Listener" Cmdlet verwendet, um den Listener zu erstellen. Es sollte angemerkt werden, dass die DefaultActions "authenticate-cognito" und "authenticate-oidc" nicht funktionieren. Dies liegt daran, dass diese Actions erweiterte HTTPS Authentifizierungsfunktionen und aufgrund damals fehlender Zertifikate noch nicht vollständig implementiert sind. Die entsprechenden Parameter sind in den Kommentaren aufgeführt.
Im Anhang findet man alle weiteren PS Skripte, die ich erstellt habe. Der Aufbau der Skripte ist sehr ähnlich wie der des beschriebenen "Create" Skripts. Es ist auch vorgesehen gewesen, dass wichtige Eckdaten zu Kunden, Loadbalancer, ausgeführte Aktionen und Logging in der ACP Datenbank eingetragen werden. Leider konnte ich dies aus mangelnder Zeit nicht mehr in die Skripte implementieren.


# Praxisphase 4


## Motivation 

Nachdem ich meine vorherigen Praxisphasen damit verbracht habe mich in das Themenumfeld Public Cloud einzuarbeiten und die Grundlagen abzudecken, habe ich mich dazu entschieden, zur Abwechslung ein etwas anderes Thema anzunehmen und .

## Problemstellung 

Es soll ein Feedbackprozess für die Abteilung als Applikation digitalisiert und visualisiert werden.Die Visualisierung soll in Form von Diagrammen erfolgen, welche geeignete Metriken zur Evaluierung der Abteilung darstellen. Nach Abschluss des Entwicklungsprozesses soll die Anwendung Container in der Public Cloud gehostet werden.


## Grundlagen 

In diesem Abschnitt sollen Grundlagen wie verwendete Technologien, Lösungsverfahren und weitere relevante Themen im Kontext der 4. Praxisphase erläutert werden. 



### Verwendete Tools & Programme 

#### Angular 

"Angular ist die nächste Version des OpenSource Frameworks AngularJS. Die Code-Basis wurde komplett neu geschrieben und nutzt nun als Basis die Sprache TypeScript. Grundidee und Konzepte des Frameworks sind jedoch identisch geblieben was eine Migration oder sogar einen hybriden Einsatz der Versionen ermöglicht. Der Fokus des Projektes hat sich von der Entwicklung eines Frameworks auf die Entwicklung einer ganzen Plattform für WebAnwendungen erweitert. Aktuell arbeiten über 30 MitarbeiterInnen fest an dem Projekt und werden von hunderten Entwicklern aus der OpenSource-Community unterstützt. Durch die Einführung von Werkzeugen wie dem Kommandozeilenwerkzeug Angular-CLI können Projekte jetzt noch schneller erstellt und in Produktion überführt werden." [@WasSindAngulara] 

#### Angular: Tour of Heroes - Eine Einführung in die Entwicklung von Web-Anwendungen 


Um ein grundlegendes Verständnis von der Funktionsweise von Angular zu bekommen, habe ich die "Tour of Heroes" bearbeitet, welches ein Tutorial von den Entwicklern von Angular ist. Es wird gezeigt wie man seine lokale Entwicklungsumgebung aufsetzt und eine Anwendung entwickelt, deren Funktionen man in den meisten datengebundenen Applikation wiederfinden kann. Nach Abschluss des Tutorials hat man die Kenntnisse, um folgende Funktionen zu entwickeln:


- "Das Nutzen von eingebauten Angular *directives*, um Elemente verstecken und anzuzeigen
- Erstellen von Angular *components* für das Zeigen von Arrays und Details von Heroes
- Benutzung von *one-way data binding* für read-only Daten
- Hinzufügen von bearbeitbaren fields, um ein Modell mit two-way data binding zu aktualisieren
- Binden von *component* Methoden an User Events, um die Anwendung zu steuern
- Benutzern ermöglichen Heroes auszuwählen in einer master list und zu verändern in der details view
- Daten Formatieren durch piping
- Erstellen eines geteilten *service* für die Fertigung der Heroes
- Nutzen von Routing, um durch die verschiedenen views und deren components zu navigieren"

#### Powershell 


Die Windows Powershell wurde hauptsächlich dazu genutzt, um das Bereitstellen von Google Cloud Resourcen zu automatisieren.
Anstelle der manuellen Eingabe von Spezifikationen, werden Skripts verwendet, welche die gewünschten Resourcen anzufordern. 
"Mit Cloud Tools for PowerShell kann man für Windows-Arbeitslasten, die auf der Google Cloud Platform ausgeführt werden, Skripte erstellen und die Arbeitslasten automatisieren und verwalten." [@CloudToolsPowerShell]


Hier einige Beispiele: 

```{.gCloudBasicCommands .numberLines startFrom=0}
# Create small VM
gcloud compute instances create test-instance-jenu-1
--project=azubi-knowhow-building --zone=us-central1-a --machine-type=e2-micro

# Check Default regions/zones
gcloud config get-value compute/zone
gcloud config get-value compute/region

# Check all available regions/zones
gcloud compute zones list
gcloud compute regions list

# Remove Metadata
gcloud compute project-info remove-metadata
\ --keys=google-compute-default-region,google-compute-default-zone

```
Auch im Entwicklungsprozess des Backends wurde Powershell verwendet, um lokale Entwicklungsserver zu starten oder Python Erweiterungen zu installieren.


#### Docker 

"Docker ist eine offene Plattform für die Entwicklung, Bereitstellung und Ausführung von Anwendungen. Docker ermöglicht es, Anwendungen von Infrastruktur zu trennen, damit Software schnell bereitgestellt werden kann. Mit Docker kann Infrastruktur auf die gleiche Weise wie Anwendungen verwalten werden. Indem die Vorteile der Docker-Methoden für die schnelle Bereitstellung, das Testen und die Implementierung von Code genutzt werden, wird die Zeitspanne zwischen dem Schreiben des Codes und seiner Ausführung in der Produktion deutlich verkürzt." [@DockerOverview2022]

"Es besteht die Möglichkeit, eine Anwendung in einer lose isolierten Umgebung, einem Container, zu verpacken und auszuführen. Die Isolierung und Sicherheit ermöglicht es, viele Container gleichzeitig auf einem bestimmten Host auszuführen. Container sind leichtgewichtig und enthalten alles, was für die Ausführung der Anwendung erforderlich ist, sodass nicht darauf geachtet werden muss, was derzeit auf dem Host installiert ist." [@DockerOverview2022]

Vorteile:

- Entwicklung von Anwendungen und unterstützende Komponenten in Containern
- Container wird zur Einheit für die Verteilung und das Testen von Anwendungen
- Bereitstellen der Anwendung in Produktionsumgebung als Container oder orchestrierten Dienst, was unabhängig davon funktioniert, ob die Produktionsumgebung ein lokales Rechenzentrum, ein Cloud-Anbieter oder eine Mischung aus beidem ist [@DockerOverview2022]


#### Flask Python

"Flask ist ein in Python geschriebenes Framework für Webanwendungen. Flask basiert auf dem Werkzeg WSGI Toolkit und der Jinja2 Template Engine, beides Pocco Projekte.

WSGI:

Die Webserver-Gateway-Schnittstelle (Web Server Gateway Interface, WSGI) wurde als Standard für die Entwicklung von Webanwendungen in Python verwendet. WSGI ist die Spezifikation einer gemeinsamen Schnittstelle zwischen Webservern und Webanwendungen.


Werkzeug:

Werkzeug ist ein WSGI-Toolkit, das Anfragen, Antwortobjekte und Hilfsfunktionen implementiert. Damit kann ein Webframe darauf aufgebaut werden. Das Flask-Framework verwendet Werkzeg als eine seiner Grundlagen.

jinja2:

jinja2 ist eine beliebte Template-Engine für Python. jinja2 kombiniert ein Template mit einer spezifischen Datenquelle, um eine dynamische Webseite zu erstellen. Was erlaubt Python Variablen in eine HTML Seite zu integrieren.

Flask wird oft als Mikroframework bezeichnet. Es ist darauf ausgelegt, den Kern der Anwendung einfach und skalierbar zu halten. Anstelle einer Abstraktionsschicht für die Datenbankunterstützung unterstützt Flask Erweiterungen, um der Anwendung Funktionen hinzuzufügen.

Warum Flask als Backend Framework?

Im Gegensatz zu Django, ein weiteres python-basiertes Webframework ist Flask sehr "Pythonic" heißt es ist einfach zu verstehen und hat keine so große Lernkurve. Zusätzlich dazu ist Flask sehr explizit, was bedeutet das der Code sehr einfach zu lesen ist. Es ist zwar ein Mikroframework aber das nicht das man den ganzen Code in eine Datei schreibt, mehrere Dateien sollten für komplexere Programme verwendet werden. Das Framework ist simpel aber dennoch erweiterbar und alle Entscheidungen liegen bei dem Entwickler, z.b. welche Datenbank man benutzt. Flask ist sehr beliebt, weshalb auch eine große Opensource Community enstanden ist, welche viele weitere Erweiterungen entwickelt haben." [@WhatFlaskPython]

#### PostgreSQL

"PostgreSQL ist eine relationale Datenbank, die auf der POSTGRES Version 4.2 basiert. Die Größe einer Datenbank ist unbegrenzt und eine Tabelle kann bis zu 64 Terra-Byte groß werden. Bei der Anzahl der Datensätze gibt es keine Grenzen (der verfügbare Plattenplatz einmal ausgenommen). Die Anzahl der Spalten ist auf 1600 begrenzt und jede Spalte nimmt maximal Daten bis zu einem Gigabyte auf. Ein weiterer Pluspunkt der Datenbank sind die Funktionen. Mit ihnen kann man direkt SQL-Befehle auf der Datenbank ausführen."[@WasIstPostgreSQL]

#### Postman

"Postman ist eines der beliebtesten Werkzeuge zum Testen von APIs (Application Programming Interfaces). Haupteinsatzgebiet ist das Testen von REST APIs auf HTTP-Basis. Der grundlegende Aufbau fokussiert sich dabei auf das Verarbeiten und Validieren von Requests und deren Responses. HTTP-Requests lassen sich in Postman mit zugehörigen Parametern über den visuellen Request-Builder spezifizieren und absenden. Die Responses können direkt angesehen und ausgewertet werden, sei es grafisch oder über die interne Programmierschnittstelle von Postman mittels JavaScript. Prinzipiell können in Postman alle Aspekte von einem Request dargestellt und transparent geändert werden können, u.a. die Request-Art, Authentifizierung, die übergebenen Parameter oder die lokalen Cookies. Hilfreich ist dies nicht nur bei der Entwicklung von eigenen neuen APIs, sondern auch bei der Verwendung von bereits existierenden, da leicht ersichtlich ist welche Parameter übergeben werden und wie der Rückgabewert aussieht."[@siebertPostmanAPI]

## Ausarbeitung - Automatisierung Feedbackprozess

### Projektbeschreibung

Im Rahmen der Praxisphase sollen Studenten und Auszubildende, für die Abteilung in der sie gearbeitet haben Feedback zur Arbeit, in Form eines PDF-Bogens, an die Abteilung und an die Personalabteilung abgeben. Dieser Feedbackprozess soll automatisiert werden. Als Beispiel hier die erste Seite des Bogens (restlichen Seiten im befinden sich im Anhang) :

![Feedbackbogen](Feedbackbsp-001.jpg){#fig:feedbackbsp}

Für diese Aufgabe hat sich ein kleines Projektteam, aus vier Studenten (inklusive mir), gebildet. Die Projektowner sind unsere Betreuer und diese stellen uns Anforderungen und geben uns, während dem Entwicklungsprozesses kontinuierlich Feedback. Die Anforderungen sind unter anderem:

- Loginfunktion
- GUI für den Feedbackbogen
- Verarbeitung anonymisierter Daten vom Feedbackbogen
- Dashboard mit Abteilungsauswahl zur Darstellung der Abteilungsbewertungen
- PDF-Export des Feedbackbogens
- Aufbau einer Continous Integration Pipeline
- Continuous Deployment von neuen Versionen

### Struktur

![Aufbau](Web-Architektur.png){#fig:webarchitektur}

In dieser Abbildung ist die Architektur des Projekts dargestellt. Die Anwendung soll nur von Studenten und Betreuer der Abteilung benutzt werden können. Diese sollen in der Zukunft über einen Backend-Service (vorraussichtlich über den Firebase Authentication Dienst [@FirebaseAuthentication] ) authentifiziert und in der Datenbank geloggt werden. Nach dem Einloggen können Studenten ihr Feedbackformular ausfüllen und abschicken. Die Daten werden einer Request an das Backend gesendet, welche die Bewertungen in der Datenbank speichert. Über das Dashboard können Betreuer die Ergebnisse der Feedbackbögen in Form von geeigneter Metriken einsehen. Die Entwicklung des Frontends erfolgt im Rahmen des Angular Web-Frameworks, die Continous Integration und Continuous Deployment wird von dem Rest des Projektteams ausgearbeitet. Das Backend und die API wird von mir im Python Flask Framework implementiert.

### Implementierung Backend

Main APP:

```{.app.py .numberLines startFrom="1"}

from flask import Flask
from flask import send_from_directory

app = Flask(__name__)

@app.route('/<path:filepath>')
def send_report(filepath):
    return send_from_directory('Feature\dist\feature', filepath)

@app.route('/login')
@app.route('/statistik')
@app.route('/header')
@app.route('/toolbar')
@app.route('/dashboard')
@app.route('/feedback')
@app.route('/')
def send_index():
    return send_from_directory('Feature\dist\feature', 'index.html')

```

Bisher dient die app.py nur dazu das Routing der urls in der Entwicklungsumgebung zu regeln. Die einzelnen Seiten werden über die URL aufgerufen. Die einzelnen Seiten werden in Angular implementiert, in dem "feature" Ordner bzw. in der index.html gespeichert.


API: 
```{.apy.py .numberLines startFrom="1"}
from app import app
from flask import request
import psycopg
from flask import jsonify

conn = psycopg.connect(dbname='postgres', host='host',
                        user='postgres', password='PW')

```
Zunächst wird für das Routing die app.py importiert. Die API basiert auf der REST Architektur (Representational State Transfer) heißt sie überträgt eine Repräsentation des Ressourcenstatus an den Endpunkt in einem bestimmten Format, in diesem Fall JSON. Hierfür werden aus flask die Module request und jsonify importiert, um die Verarbeitung von HTTP Requests und JSON zu gewährleisten. Die Datenbankverbindung wird über den psycopg Datenbank Adapter ermöglicht.

```{.apy.py .numberLines startFrom="8"}
@app.route('/api/feedback', methods=['POST'])
def receive_feedback():
    if request.content_type == 'application/json':
        data = request.json
        options = range(0, 7)
        try:
            # check if root data is valid
            if not isinstance(data['abteilung'], str):
                return 'abteilung not a string', 400
            if not isinstance(data['studiengang'], str):
                return 'studiengang not a string', 400
            if not isinstance(data['praxiszeitraum'], str):
                return 'praxiszeitraum not a string', 400
            if not isinstance(data['einstelljahr'], int):
                return 'einstelljahr not a int', 400
            if not isinstance(data['betreuer'], str):
                return 'betreuer not a string', 400
            if not isinstance(data['student'], str):
                return 'student not a string', 400
            # check if betreuung data is in range
            if data['betreuung']['vorbereitung'] not in options:
                return 'betreuung.vorbereitung is not in range', 400
            if data['betreuung']['ausstattung'] not in options:
                return 'betreuung.ausstattung is not in range', 400
            if data['betreuung']['arbeitsablaeufe'] not in options:
                return 'betreuung.arbeitsablaeufe is not in range', 400
            if data['betreuung']['ansprechpartner'] not in options:
                return 'betreuung.ansprechpartner is not in range', 400
            if data['betreuung']['einbindung'] not in options:
                return 'betreuung.einbindung is not in range', 400
            if data['betreuung']['anwendung'] not in options:
                return 'betreuung.anwendung is not in range', 400
            if not isinstance(data['betreuung']['kommentar'], str):
                return 'betreuung.kommentar is not a string', 400
            # check if wissensaustausch data is in range
            if data['wissensaustausch']['fachwissen'] not in options:
                return 'wissensaustausch.fachwissen is not in range', 400
            if data['wissensaustausch']['gesamtprozess'] not in options:
                return 'wissensaustausch.gesamtprozess is not in range', 400
            if data['wissensaustausch']['informationsgespraeche'] not in options:
                return 'wissensaustausch.informationsgespraeche is not in range', 400
            if not isinstance(data['wissensaustausch']['kommentar'], str):
                return 'wissensaustausch.kommentar is not a string', 400
            # check if mitarbeit data is in range
            if data['mitarbeit']['praktisch'] not in options:
                return 'mitarbeit.praktisch is not in range', 400
            if data['mitarbeit']['ausbildungsrelevanz'] not in options:
                return 'mitarbeit.ausbildungsrelevanz is not in range', 400
            if data['mitarbeit']['eigenverantwortung'] not in options:
                return 'mitarbeit.eigenverantwortung is not in range', 400
            if data['mitarbeit']['praxisbericht'] not in options:
                return 'mitarbeit.praxisbericht is not in range', 400
            if not isinstance(data['mitarbeit']['kommentar'], str):
                return 'mitarbeit.kommentar is not a string', 400
            if not isinstance(data['abschlussbemerkungen'], str):
                return 'abschlussbemerkungen is not a string', 400
        except Exception as e:
            return f'Error: {e}', 400
```
Hier beginnt die POST Request Methode. Es wird geprüft ob die Daten im JSON Format vorliegen. Falls nicht, wird eine Fehlermeldung zurückgegeben. Anschließend werden die einzelnen Daten aus dem JSON Objekt ausgelesen und geprüft ob sie in den erlaubten Bereich fallen und ob die Datentypen auch stimmen. Man könnte argumentieren, dass die Prüfung der Datentypen nicht zwingend notwendig ist, da, wenn sie später in die Datenbank gespeichert werden, Postgres automatisch den INSERT aufgrund von falschen Datentypen blockiert. Aber ich habe vorgesehen, dass das Errorhandling von Requests so weit es geht von der API abgedeckt wird.

```{.apy.py .numberLines startFrom="66"}

        # insert json data into database
        conn.execute(""" INSERT INTO public.feedbackdata(
	abteilung, 
    studiengang, 
    praxiszeitraum, 
    einstelljahr, 
    betreuer, 
    student, 
    vorbereitung, 
    ausstattung, 
    arbeitsablauf, 
    ansprechpartner, 
    einbindung, 
    anwendung, 
    kommentar_betreuung, 
    fachwissen, 
    gesamtprozess, 
    informationsgespraeche, 
    kommentar_wissen, 
    praktisch, 
    ausbildungsrelevanz, 
    eigenverantwortung, 
    praxisbericht, 
    kommentar_mitarbeit, 
    bemerkungen)
	VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, 
    %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s);""",
       (
        data['abteilung'],
        data['studiengang'],
        data['praxiszeitraum'],
        data['einstelljahr'],
        data['betreuer'],
        data['student'],
        data['betreuung']['vorbereitung'],
        data['betreuung']['ausstattung'],
        data['betreuung']['arbeitsablaeufe'],
        data['betreuung']['ansprechpartner'],
        data['betreuung']['einbindung'],
        data['betreuung']['anwendung'],
        data['betreuung']['kommentar'],
        data['wissensaustausch']['fachwissen'],
        data['wissensaustausch']['gesamtprozess'],    
        data['wissensaustausch']['informationsgespraeche'],
        data['wissensaustausch']['kommentar'],
        data['mitarbeit']['praktisch'],
        data['mitarbeit']['ausbildungsrelevanz'],
        data['mitarbeit']['eigenverantwortung'],
        data['mitarbeit']['praxisbericht'],
        data['mitarbeit']['kommentar'],
        data['abschlussbemerkungen']))
        
        conn.commit()
        
        return 'OK'
    else:
        return 'Invalid content type', 406
```
Zum Ende der POST Methode wird die Datenbankverbindung aufgebaut und die Daten aus dem JSON Objekt in die Datenbank geschrieben. Anschließend wird die Datenbankverbindung geschlossen und eine OK Nachricht zurückgegeben.

```{.apy.py .numberLines startFrom="124"}
# get key data from db
@app.route('/api/summary', methods=['GET'])
def get_data():

    keydata = conn.execute("""SELECT id, abteilung, studiengang, einstelljahr, 
    betreuer, student, praxiszeitraum
	FROM public.feedbackdata;""").fetchall()

    return jsonify(keydata)
```

In dieser GET Methode werden Daten aus der Tabelle feedbackdata mit einer SQL Query ausgelesen. Anschließend wird die Datenbankverbindung geschlossen und die Daten als JSON Objekt zurückgegeben. Diese Daten dienen als Eckdaten, die später auf einer Übersichtsseite, in der alle eingereichten Bewertungen für die Betreuer angezeigt werden sollen.

```{.apy.py .numberLines startFrom="133"}	
# get data from db for statistics
@app.route('/api/score', methods=['GET'])
def get_score():

    scoreavg= conn.execute(""" SELECT
    AVG(vorbereitung),
    AVG(ausstattung),
    AVG(arbeitsablauf),
    AVG(ansprechpartner),
    AVG(einbindung),
    AVG(fachwissen),
    AVG(gesamtprozess),
    AVG(informationsgespraeche),
    AVG(praktisch),
    AVG(ausbildungsrelevanz),
    AVG(praxisbericht),
    AVG(eigenverantwortung)
    FROM public.feedbackdata;""").fetchall()
    
    avg = sum(scoreavg[0])/len(scoreavg[0])

    return jsonify({'score': scoreavg, 'totalavg': avg})
```
In der letzten GET Methode werden Durchschnittswerte für die einzelnen Fragen aus der Datenbank ausgerechnet mit einer weiteren SQL. Diese Daten werden als JSON Objekt zurückgegeben. Diese Daten werden später für die Metriken auf der Statistikseite verwendet.

Alle Methoden wurden bereits erfolgreich mithilfe von Postman getestet. Das verwendete JSON Objekt sieht wie folgt aus:

```{.json .numberLines startFrom="1"}
{
    "abteilung": "Testabteilung",
    "studiengang": "Teststudiengang",
    "praxiszeitraum": "Testzeitraum",
    "einstelljahr": "Testjahr",
    "betreuer": "Testbetreuer",
    "student": "Teststudent",
    "betreuung": {
        "vorbereitung": 1,
        "ausstattung": 0,
        "arbeitsablaeufe": 3,
        "ansprechpartner": 4,
        "einbindung": 5,
        "anwendung": 6,
        "kommentar1": "Testkommentar"
    },
    "wissensaustausch": {
        "fachwissen": 1,
        "gesamtprozess": 2,
        "informationsgespraeche": 3,
        "kommentar2": "Testkommentar"
    },
    "mitarbeit": {
        "praktisch": 1,
        "ausbildungsrelevanz": 2,
        "eigenverantwortung": 3,
        "praxisbericht": 4,
        "kommentar3": "Testkommentar"
    },
    "abschlussbemerkungen": "Testbemerkungen"
}
```

Die JSON erfüllt seinen Zweck, jedoch ist auch geplant beispielsweise bei den Eckdaten (Zeile 4) das Praxiszeitraum Key-Value-Paar so zu modifizieren, dass bei den Statistiken auch Trends visualisiert werden können.

Datenbank:

Da wir bisher nur eine Tabelle in der Datenbank haben, ist diese auch noch nicht so komplex. Die Tabelle feedbackdata sieht wie folgt aus:

```{.sql .numberLines startFrom="1"}
CREATE TABLE IF NOT EXISTS public.feedbackdata
(
    id bigint NOT NULL GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 
    MAXVALUE 9223372036854775807 CACHE 1 ),
    abteilung text COLLATE pg_catalog."default" NOT NULL,
    studiengang text COLLATE pg_catalog."default" NOT NULL,
    praxiszeitraum text COLLATE pg_catalog."default" NOT NULL,
    einstelljahr text COLLATE pg_catalog."default" NOT NULL,
    betreuer text COLLATE pg_catalog."default" NOT NULL,
    student text COLLATE pg_catalog."default",
    vorbereitung integer NOT NULL,
    ausstattung integer NOT NULL,
    arbeitsablauf integer NOT NULL,
    ansprechpartner integer NOT NULL,
    einbindung integer NOT NULL,
    anwendung integer NOT NULL,
    kommentar_betreuung text COLLATE pg_catalog."default",
    fachwissen integer NOT NULL,
    gesamtprozess integer NOT NULL,
    informationsgespraeche integer NOT NULL,
    kommentar_wissen text COLLATE pg_catalog."default",
    praktisch integer NOT NULL,
    ausbildungsrelevanz integer NOT NULL,
    eigenverantwortung integer NOT NULL,
    praxisbericht integer NOT NULL,
    kommentar_mitarbeit text COLLATE pg_catalog."default",
    bemerkungen text COLLATE pg_catalog."default",
    CONSTRAINT feedbackdata_pkey PRIMARY KEY (id)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.feedbackdata
    OWNER to postgres;
```

Ausblick:

Das Projekt befindet sich derzeit noch in der frühen Entwicklung. In der Zukunft sollen weitere Funktionen hinzugefügt werden. Unter anderem die Containerisierung der Anwendung mithilfe von Docker. Außerdem soll die Anwendung nach der Entwicklung in der Google Public Cloud laufen.

# Danksagung 

Vielen Dank an meine Betreuer, insbesondere: Jörg Deutschmann und Robin Walter, die die Projektarbeit direkt betreuen sowie Mathias Lehnert und Jakob Planz, die mir das Vertrauen entgegengebrachten und mir einen Platz in ihren jeweiligen Abteilungen geboten haben.

# Anhang

Hier finden sich Code und weitere relevante Anhänge. Aus Gründen der Lesbarkeit wurden einige Änderungen vorgenommen, die nicht der gewünschten Syntax der Powershell entsprechen.

## Code: AWS Powershell Skripts

### Modify ALB

```{.Atos.Cloud.AWS.Loadbalancer.Modify .numberLines startFrom=1}
<#
.SYNOPSIS
.DESCRIPTION
    Please read the full Description first before using this PS script file.
    This PS script allows you to edit Elastic LoadBalancer Subnets and 
    IpAddressType, TargetGroup Ports, Listener Ports and DefaultAction
    Features:
        - JSON input parameters
            - Requires following input parameters
                - LoadBalancers:
                    - LoadBalancer Name [string]
                    - LoadBalancer Region [string]
                    - two subnets in two different Availabiltity Zones [string]
                    - IpAddressType [string]
                - TargetGroups
                    - TargetGroupName [string]
                    - Port [int32]
                    - Protocol [string]
                    - ProtocolVersion [string]
                        - Currently only supports HTTP Protocol
                -Listeners:
                    - LoadBalancer Name [string]
                    - LoadBalancer Region [string]
                    - Port of Listener [int32]
                    - To change Port: current Port and NewPort are required [int32]
                    - DefaultAction [string]
                        - TargetGroup Name required for Defaultaction "forward"
        - Set LoadBalancer subnet
        - Set LoadBalancer IP AddressType
        - Set TargetGroup Port
        - Set Listener Port
        - Set Listener DefaultAction
    Future implementation plans:
        - Add Error Handling
        - Set LoadBalancer Attributes
        - Add support for processing all possible DefaultActions
        - Add support for HTTPS Protocol
SOURCE:
https://docs.aws.amazon.com/powershell/latest/reference/items/Edit-ELB2TargetGroup.html 
.EXAMPLE
.NOTES
    File Name      : Atos.Cloud.AWS.Loadbalancer.Modify.HC
    Author         : Jenusan Baskaran
    Prerequisite   : PowerShell 5.1
    Version        : 202200322
#>

Param(
	# [Parameter(Mandatory)] [string] $fullConfig

)
Process{
    $startTime = Get-Date
	
	$fullConfig = Get-Content 
    "C:\Users\jenujenujenu\Documents\PS_Scripts_AWS\AWS_Actions_Git\
    AWS Basic Automation\examples\input\LoadBalancer\ParameterJSON_min_LB.json"

	#Import-Module AWSPowerShell
    #$ServiceProfile "acpauto"
    #Set-AWSCredential -ProfileName $ServiceProfile


	if ($fullConfig) {
		$Config = [PSObject] ($fullConfig | ConvertFrom-Json)
		$LBcount = $Config.LoadBalancers.length #LB counter
	} else {
		$LBcount = 1
	}
	"$LBcount LoadBalancer to deploy"

	# Loop through LB Array from JSON input
	for ($i=0; $i -lt $LBcount; $i++){

		if ($fullConfig) {
			if($null -ne $Config.Customer){
				$Customer = $Config.Customer
			}
			if ($null -ne $Config.Loadbalancers[$i].Location) {
				$Region = $Config.Loadbalancers[$i].Location
			}
			if ($null -ne $Config.LoadBalancers[$i].IpAddressType) {
				$IpAddressType = $Config.LoadBalancers[$i].IpAddressType
			}
            if ($null -ne $Config.LoadBalancers[$i].LBName) {
				$LBName = $Config.LoadBalancers[$i].LBName
			}
            if ($null -ne $Config.LoadBalancers[$i].Networkadapters[0].Subnet) {
				$Subnet = $Config.LoadBalancers[$i].Networkadapters[0].Subnet
			}
			<#
			if ($null -ne $Config.LoadBalancers[$i].Attribute) {
				$Attribute = $Config.LoadBalancers[$i].Attribute
				$AttributeObj = New-Object Amazon.ElasticLoadBalancingV2.Model
                .LoadBalancerAttribute
			}
			#>
			
		}

        #Get LB Object and extract LoadBalancerArn for Edit- and Set- Cmdlets
		$ELB2LBObj = Get-ELB2LoadBalancer -Name $LBName -Region $Region
		$LoadBalancerArn = $ELB2LBObj.LoadBalancerArn

        #Change Subnet
        if ($null -ne $Config.LoadBalancers[$i].Networkadapters[0].Subnet) {
            Set-ELB2Subnet -Subnet $Subnet -LoadBalancerArn $LoadBalancerArn
        }
        #Change IpAddressType
        if ($null -ne $Config.LoadBalancers[$i].IpAddressType) {

            Set-ELB2IpAddressType 
            -IpAddressType $IpAddressType 
            -LoadBalancerArn $LoadBalancerArn
        }
        #Change Attributes
        <#
			if ($null -ne $Config.LoadBalancers[$i].Attribute) {
				$Attribute = $Config.LoadBalancers[$i].Attribute
				$AttributeObj = New-Object Amazon.ElasticLoadBalancingV2.Model
                .LoadBalancerAttribute
                Edit-ELB2LoadBalancerAttribute 
                -LoadBalancerArn $LoadBalancerArn 
                -Attribute $AttributeObj
			}
			#>
		$endTime= Get-Date

		$msg = 'Modification of the LoadBalancer {0} with type of {1} for customer {2}
         has been completed with start time {3} and end time {4}' -
         f $LBName, $LBName, $Customer, $startTime, $endTime

		Write-Output $msg
	
        #Edit TargetGroups
		$startTime = Get-Date

		if ($fullConfig) {
			$TGcount = $Config.LoadBalancers[$i].TargetGroups.length
		} else {
			$TGcount = 1
		}
		"$TGcount TargetGroups to modify"

		#Loop through TG Array from JSON input
    	for ($j=0; $j -lt $TGcount; $j++){

			if ($fullConfig) {
                if ($null -ne $Config.LoadBalancers[$i].TargetGroups.TGName) {
                    $TGName =  $Config.LoadBalancers[$i].TargetGroups.TGName
                }
        	    if ($null -ne $Config.LoadBalancers[$i].TargetGroups[$j].Port) {
        	        $TGPort = $Config.LoadBalancers[$i].TargetGroups[$j].Port
        	    }
				if ($null -ne $Config.LoadBalancers[$i].TargetGroups[$j].Protocol) {
            		$TGProtocol = $Config.LoadBalancers[$i].TargetGroups[$j].Protocol
       		    }
				if ($null -ne $Config.LoadBalancers[$i].TargetGroups[$j]
                .ProtocolVersion) {
         	    	$TGProtocolVersion = $Config.LoadBalancers[$i].TargetGroups[$j]
                    .ProtocolVersion
            	}
            	if ($null -ne $Config.LoadBalancers[$i].TargetGroups[$j]
                .Matcher_GrpCode) {
                	$Matcher_GrpCode = $Config.LoadBalancers[$i].TargetGroups[$j]
                    .Matcher_GrpCode
            	}	
            	if ($null -ne $Config.LoadBalancers[$i].TargetGroups[$j]
                .Matcher_HttpCode) {
                	$Matcher_HttpCode = $Config.LoadBalancers[$i].TargetGroups[$j]
                    .Matcher_HttpCode
            	}
        	}
    
		Edit-ELB2TargetGroup 
        -Region $Region 
        -Name $TGName 
        -Port $TGPort 
        -Protocol $TGProtocol 
        -ProtocolVersion $TGProtocolVersion 

		$ELB2TGObj = Get-ELB2TargetGroup -Name $TGName -Region $Region
		
	}

    #Edit Listeners
	$startTime = Get-Date

        if ($fullConfig) {
            $Config = [PSObject] ($fullConfig | ConvertFrom-Json)
            $LIScount = $Config.LoadBalancers[$i].Listeners.length
        } else {
            $LIScount = 1
        }

		# Get Parameter Input from JSON for Listeners
        for ($j = 0; $j -lt $LIScount; $j++) {

            if ($fullConfig) {
            if ($null -ne $Config.LoadBalancers[$i].Listeners[$j].AlpnPolicy) {
                $AlpnPolicy = $Config.LoadBalancers[$i].Listeners[$j].AlpnPolicy
            }
            if ($null -ne $Config.LoadBalancers[$i].Listeners[$j].Certificate) {
                $Certificate = $Config.LoadBalancers[$i].Listeners[$j].Certificate
            }
            if ($null -ne $Config.LoadBalancers[$i].Listeners[$j].DefaultAction){
                $DefaultAction = $Config.LoadBalancers[$i].Listeners[$j].DefaultAction
            }
            if ($null -ne $Config.LoadBalancers[$i].Listeners[$j].Port) {
                $Port = $Config.LoadBalancers[$i].Listeners[$j].Port
            }
            if ($null -ne $Config.LoadBalancers[$i].Listeners[$j].NewPort) {
                $NewPort = $Config.LoadBalancer[$i].Listeners[$j].NewPort
            }
            if ($null -ne $Config.LoadBalancers[$i].Listeners[$j].Protocol) {
                $Protocol = $Config.LoadBalancers[$i].Listeners[$j].Protocol
            }
            if ($null -ne $Config.LoadBalancers[$i].Listeners[$j].SslPolicy) {
                $SslPolicy = $Config.LoadBalancers[$i].Listeners[$j].SslPolicy
            }
        }

        #Edit Port
        if ($null -ne $NewPort) {
            #Get all ListenerArn
            $ELB2LisObj= Get-ELB2Listener 
            -Region $Region 
            -LoadBalancerArn $LoadBalancerArn

            $ListenerArn = $ELB2LisObj.where({ ($_).Port -eq $Port }).ListenerArn
            Edit-ELB2Listener -ListenerArn $ListenerArn -Port $NewPort

        }

        #Edit DefaultAction
        if($null -ne $DefaultAction){

            #Get all ListenerArn
            $ELB2LisObj= Get-ELB2Listener 
            -Region $Region 
            -LoadBalancerArn $LoadBalancerArn

            #Filter Listeners with Port
            $ListenerArn = $ELB2LisObj.where({ ($_).Port -eq $Port }).ListenerArn 
            #Get TargetGroupARN from ELB2TGObj for DefaultAction
            $TargetGroupArn = $ELB2TGObj.TargetGroupArn 
    
            switch ($DefaultAction) {
                forward {
                    $DefaultActionObject = 
                    New-Object Amazon.ElasticLoadBalancingV2
                    .Model.Action
                    $DefaultActionObject.ForwardConfig = 
                    New-Object Amazon.ElasticLoadBalancingV2
                    .Model.ForwardActionConfig
                    $DefaultActionObject.Type =$DefaultAction
                    $DefaultActionObject.TargetGroupArn =$TargetGroupArn
                }
                fixed-response{
                    $DefaultActionObject = New-Object Amazon.ElasticLoadBalancingV2
                    .Model.Action
                    $DefaultActionObject.FixedResponseConfig = 
                    New-Object Amazon.ElasticLoadBalancingV2
                    .Model.FixedResponseActionConfig

                    $DefaultActionObject.Type =$DefaultAction
                    $DefaultActionObject.FixedResponseConfig.StatusCode = 200
                    $DefaultActionObject.FixedResponseConfig.ContentType = text/plain
                    $DefaultActionObject.FixedResponseConfig.MessageBody = 
                    'This is a fixed response. Kind of obvious huh?'
                }
                redirect{
                    $DefaultActionObject = New-Object Amazon.ElasticLoadBalancingV2
                    .Model.Action
                    $DefaultActionObject.RedirectConfig =
                    New-Object Amazon.ElasticLoadBalancingV2
                    .Model.RedirectActionConfig

                    $DefaultActionObject.Type =$DefaultAction
                    <#
                    $DefaultActionObject.RedirectConfig.Host =
                    $DefaultActionObject.RedirectConfig.Path =
                    $DefaultActionObject.RedirectConfig.Port =
                    $DefaultActionObject.RedirectConfig.Protocol =
                    $DefaultActionObject.RedirectConfig.Query =
                    $DefaultActionObject.RedirectConfig.StatusCode =
                    #>
                }
                authenticate-cognito{
                    $DefaultActionObject = New-Object Amazon.ElasticLoadBalancingV2
                    .Model.Action
                    $DefaultActionObject.AuthenticateCognitoConfig = 
                    New-Object Amazon.ElasticLoadBalancingV2
                    .Model.AuthenticateCognitoActionConfig

                    $DefaultActionObject.Type =$DefaultAction
                    <#
                    $DefaultActionObject.AuthenticateCognitoConfig
                    .AuthenticationRequestExtraParams =
                    $DefaultActionObject.AuthenticateCognitoConfig
                    .OnUnauthenticatedRequest =
                    $DefaultActionObject.AuthenticateCognitoConfig
                    .Scope =
                    $DefaultActionObject.AuthenticateCognitoConfig
                    .SessionCookieName =
                    $DefaultActionObject.AuthenticateCognitoConfig
                    .UserPoolArn =
                    $DefaultActionObject.AuthenticateCognitoConfig
                    .UserPoolClientId =
                    $DefaultActionObject.AuthenticateCognitoConfig
                    .UserPoolDomain =
                    #>
                }
                authenticate-oidc{
                    $DefaultActionObject = 
                    New-Object Amazon.ElasticLoadBalancingV2.Model.Action
                    $DefaultActionObject.AuthenticateOidcConfig = 
                    New-Object Amazon.ElasticLoadBalancingV2
                    .Model.AuthenticateOidcActionConfig

                    $DefaultActionObject.Type =$DefaultAction
                    <#
                    $DefaultActionObject.AuthenticateOidcConfig
                    .AuthenticationRequestExtraParams =
                    $DefaultActionObject.AuthenticateOidcConfig
                    .AuthorizationEndpoint =
                    $DefaultActionObject.AuthenticateOidcConfig
                    .ClientId =
                    $DefaultActionObject.AuthenticateOidcConfig
                    .ClientSecret =
                    $DefaultActionObject.AuthenticateOidcConfig
                    .Issuer =
                    $DefaultActionObject.AuthenticateOidcConfig
                    .OnUnauthenticatedRequest =
                    $DefaultActionObject.AuthenticateOidcConfig
                    .Scope =
                    $DefaultActionObject.AuthenticateOidcConfig
                    .SessionCookieName =
                    $DefaultActionObject.AuthenticateOidcConfig
                    .SessionTimeout =
                    $DefaultActionObject.AuthenticateOidcConfig
                    .TokenEndpoint =
                    $DefaultActionObject.AuthenticateOidcConfig
                    .UseExistingClientSecret =
                    $DefaultActionObject.AuthenticateOidcConfig
                    .UserInfoEndpoint =
                    #>
                }   
                Default {
                $err = 'Cannot identify value of default action'
                Write-Output $err
                }
            }
            Edit-ELB2Listener -ListenerArn $ListenerArn -DefaultAction $DefaultActionObject
        }
        
        $endTime = Get-Date
        
        $msg = 'Modification of Listener {0} for customer {1}
        has been completed with start time {2} and end time {3}' 
        -f $ListenerArn, $Customer, $startTime, $endTime

        Write-Output $msg
        }
    }
}
```

### Modify Target Group Security Group

```{.Atos.Cloud.AWS.Loadbalancer.TargetGroup.ModifySG .numberLines startFrom=1}
<#
.SYNOPSIS
.DESCRIPTION
    Please read the full Description first before using this PS script file.
    This PS script associates the specified security groups with 
    the specified Application Load Balancer.
    Features:
        - JSON input parameters
        - Requires following input parameters
            - LoadBalancer Name [string]
            - LoadBalancer Region [string]
            - Atleast one or more SecurityGroups [string]
        - Specified SecurityGroups override previously associated SecurityGroups.
        - Cannot specify security group for Network Load Balancer or Gateway Load Balancer.
SOURCE:
https://docs.aws.amazon.com/powershell/latest/reference/items/Set-ELB2SecurityGroup.html
.EXAMPLE
.\Atos.Cloud.AWS.LoadBalancer.Modify.SG.ps1 -Customer ACP-Dev-JB -Region eu-west-1 
-LoadBalancerArn $LBARN
-SecurityGroup  $SG
.NOTES
    File Name      : Atos.Cloud.AWS.Loadbalancer.Modify.SG
    Author         : Jenusan Baskaran
    Prerequisite   : PowerShell 5.1
    Version        : 20220323
#>
Param(
    #[Parameter(Mandatory)] [string] $fullConfig

)
Process{
    $startTime = Get-Date

    $fullConfig = Get-Content 
    "C:\Users\jenujenujenu\Documents\PS_Scripts_AWS\AWS_Actions_Git\
    AWS Basic Automation\examples\input\LoadBalancer\ParameterJSON_min_LB.json"

    #Import-Module AWSPowerShell
    #$ServiceProfile "acpauto"
    #Set-AWSCredential -ProfileName $ServiceProfile

    if ($fullConfig) {
		$Config = [PSObject] ($fullConfig | ConvertFrom-Json)
		$LBcount = $Config.LoadBalancers.length #LB counter
	} else {
		$LBcount = 1
	}
    "$LBcount LoadBalancers to modify"

    for ($i = 0; $i -lt $LBcount; $i++) {
        if ($fullConfig) {
            if($null -ne $Config.Customer){
                $Customer = $Config.Customer
            }
            if ($null -ne $Config.LoadBalancers[$i].Location) {
                $Region = $Config.LoadBalancers[$i].Location
            }
            if ($null -ne $Config.LoadBalancers[$i].LBName) {
                $LBName = $Config.LoadBalancers[$i].LBName
            }
            if ($null -ne $Config.LoadBalancers[$i].NetworkAdapters[0]
            .SecurityGroups[0]) {
                $SecurityGroup = $Config.LoadBalancers[$i].NetworkAdapters[0]
                .SecurityGroups[0]
            }
        }

        $ELB2LBObj = Get-ELB2LoadBalancer -Region $Region -Name $LBName
        $LoadBalancerArn = $ELB2LBObj.LoadBalancerArn
        Set-ELB2SecurityGroup -LoadBalancerArn $LoadBalancerArn -SecurityGroup $SecurityGroup

        $endTime= Get-Date

        $msg = 'SecurityGroup(s) of Loadbalancer {0} for customer {1} 
        have been changed with start time {2} and end time {3}' 
        -f $LoadBalancerArn, $Customer, $startTime, $endTime

        Write-Output $msg
    }
}
```


### Modify Target Group Health Check

```{.Atos.Cloud.AWS.Loadbalancer.TargetGroup.ModifyHC .numberLines startFrom=1}
<#
.SYNOPSIS
.DESCRIPTION
    Please read the full Description first before using this PS script file.
    This script modifies the health checks used when evaluating 
    the health state of the targets in the specified target group.
    Features:
    - JSON input parameters
        - Requires following input parameters
            - TargetGroup Name [string]
            - TargetGroup Region [string]
            - HealthCheckIntervalSecond [int32]
            - HealthCheckPath [string]
                - Default is root "/"
            - HealthCheckPort [int32]
                - Default is "Traffic-Port" meaning the port receiving traffic
            - HealthCheckProtocol [string]
                - Default is "HTTP"
            - HealthCheckTimeoutSecond [int32]
            - HealthyThresholdCount [int32]
            - UnhealthyThresholdCount [int32]
    Future implementation plans:
        - Add Error handling
        - Add support for processing Matcher_GrpCode and MatcherHttpCode parameters
SOURCE: 
https://docs.aws.amazon.com/powershell/latest/reference/items/Edit-ELB2TargetGroup.html 
.EXAMPLE
.\Atos.Cloud.AWS.LoadBalancer.Modify.HC.ps1 -Customer ACP-Dev-JB 
-TGName $TGARN
-HealthCheckEnabled $rue -HealthCheckProtocol HTTP 
-HealthCheckPath / 
-HealthCheckPort traffic-port 
-HealthCheckIntervalSecond 30 -HealthyThresholdCount 5 -UnhealthyThresholdCount 2 
-HealthCheckTimeoutSecond 5 -Matcher_HttpCode 200
.NOTES
    File Name      : Atos.Cloud.AWS.Loadbalancer.Modify.HC
    Author         : Jenusan Baskaran
    Prerequisite   : PowerShell 5.1
    Version        : 202200323
#>

Param(
	# [Parameter(Mandatory)] [string] $fullConfig
)

Process{
    $startTime = Get-Date

    $fullConfig = Get-Content 
    "C:\Users\jenujenujenu\Documents\PS_Scripts_AWS\AWS_Actions_Git\
    AWS Basic Automation\examples\input\LoadBalancer\ParameterJSON_min_LB.json"

    #Import-Module AWSPowerShell
    #$ServiceProfile "acpauto"
    #Set-AWSCredential -ProfileName $ServiceProfile

    if ($fullConfig) {
		$Config = [PSObject] ($fullConfig | ConvertFrom-Json)
		$LBcount = $Config.LoadBalancers.length #LB counter
	} else {
		$LBcount = 1
	}
	"$LBcount LoadBalancer(s)"
    
    for($i=0; $i -lt $LBcount; $i++){
        if ($fullConfig) {
            $Config = [PSObject] ($fullConfig | ConvertFrom-Json)
            $TGcount = $Config.LoadBalancers[$i].TargetGroups.length #TG counter
        } else {
            $TGcount = 1
        }
        "$TGcount Targetgroup(s) to Modify"

        for ($j=0; $j -lt $TGcount; $j++){

            if ($fullConfig) {
                if ($null -ne $Config.Customer) {
                    $Customer = $Config.Customer
                }
                if ($null -ne $Config.LoadBalancers[$i].Location) {
                    $Region = $Config.LoadBalancers[$i].Location
                }
                if ($null -ne $Config.LoadBalancers[$i].TargetGroups[$j].TGName) {
                    $TGName = $Config.LoadBalancers[$i].TargetGroups[$j].TGName
                }
                if ($null -ne $Config.LoadBalancers[$i].TargetGroups[$j]
                .HealthCheckIntervalSecond) {
                    $HealthCheckIntervalSecond = $Config.LoadBalancers[$i].TargetGroups[$j]
                    .HealthCheckIntervalSecond
                }
                if ($null -ne $Config.LoadBalancers[$i].TargetGroups[$j].HealthCheckPath) {
                    $HealthCheckPath = $Config.LoadBalancers[$i]
                    .TargetGroups[$j].HealthCheckPath
                }
                if ($null -ne $Config.LoadBalancers[$i].TargetGroups[$j].HealthCheckPort) {
                    $HealthCheckPort = $Config.LoadBalancers[$i]
                    .TargetGroups[$j].HealthCheckPort
                }
                if ($null -ne $Config.LoadBalancers[$i].TargetGroups[$j]
                .HealthCheckProtocol) {
                    $HealthCheckProtocol = $Config.LoadBalancers[$i].TargetGroups[$j]
                    .HealthCheckProtocol
                }
                if ($null -ne $Config.LoadBalancers[$i].TargetGroups[$j]
                .HealthCheckTimeoutSecond) {
                    $HealthCheckTimeoutSecond = $Config.LoadBalancers[$i].TargetGroups[$j].HealthCheckTimeoutSecond
                }
                if ($null -ne $Config.LoadBalancers[$i].TargetGroups[$j]
                .HealthyThresholdCount) {
                    $HealthyThresholdCount = $Config.LoadBalancers[$i].TargetGroups[$j]
                    .HealthyThresholdCount
                }	
                if ($null -ne $Config.LoadBalancers[$i].TargetGroups[$j]
                .Matcher_GrpCode) {
                    $Matcher_GrpCode = $Config.LoadBalancers[$i]
                    .TargetGroups[$j].Matcher_GrpCode
                }	
                if ($null -ne $Config.LoadBalancers[$i].TargetGroups[$j]
                .Matcher_HttpCode) {
                    $Matcher_HttpCode = $Config.LoadBalancers[$i].TargetGroups[$j]
                    .Matcher_HttpCode
                }
                if ($null -ne $Config.LoadBalancers[$i].TargetGroups[$j]
                .UnhealthyThresholdCount) {
                    $UnhealthyThresholdCount = $Config.LoadBalancers[$i]
                    .TargetGroups[$j].UnhealthyThresholdCount
                }
           }
            $ELB2TGObj=Get-ELB2TargetGroup -Region $Region -Name $TGName
            $TargetGroupArn = $ELB2TGObj.TargetGroupArn

            Edit-ELB2TargetGroup 
            -Region $Region 
            -TargetGroupArn $TargetGroupArn 
            -Matcher_GrpcCode $Matcher_GrpCode 
            -HealthCheckEnabled $HealthCheckEnabled 
            -HealthCheckIntervalSecond $HealthCheckIntervalSecond 
            -HealthCheckPath $HealthCheckPath 
            -HealthCheckPort $HealthCheckPort 
            -HealthCheckProtocol $HealthCheckProtocol 
            -HealthCheckTimeoutSecond $HealthCheckTimeoutSecond 
            -HealthyThresholdCount $HealthyThresholdCount 
            -Matcher_HttpCode $Matcher_HttpCode 
            -UnhealthyThresholdCount $UnhealthyThresholdCount
            
            $endTime = Get-Date

            $msg = 'Modification of TargetGroup {0} for customer {1} 
            has been completed with start time {2} and end time {3}' 
            -f $TGName, $Customer, $startTime, $endTime

            Write-Output $msg
        }
    }
}
```

### Delete ALB

```{.Atos.Cloud.AWS.Loadbalancer.Delete .numberLines startFrom=1}	
<#
.SYNOPSIS
.DESCRIPTION
    Please read the full Description first before using this PS script file.
    This PS script is able to partly or fully remove Elastic LoadBalancer Resources
    Features:
    - Remove Elastic LoadBalancer
        - !!CAUTION!!: Removes all attached Listeners as well
        - Requires following input Parameters:
            - Region/Location of LoadBalancer
            - Name of LoadBalancer
    - Remove Listener
        - Requires following input Parameters:
            - Region/Location of LoadBalancer
            - Name of LoadBalancer
            - Port of Listener
    - Remove TargetGroup
        - Only possible if no Listeners are forwarding traffic to specified TargetGroup
        - Requires following input Parameters:
            - Region/Location of LoadBalancer
            - Name of TargetGroup
    Future implementation plans:
    - Add Error Handling
SOURCE: 
https://docs.aws.amazon.com/powershell/latest/reference/items/Remove-ELB2LoadBalancer.html
https://docs.aws.amazon.com/powershell/latest/reference/items/Remove-ELB2Listener.html
https://docs.aws.amazon.com/powershell/latest/reference/items/Remove-ELB2TargetGroup.html
.EXAMPLE
.NOTES
    File Name      : Atos.Cloud.AWS.Loadbalancer.Remove
    Author         : Jenusan Baskaran
    Prerequisite   : PowerShell 5.1
    Version        : 20220322
#>


Process {
    $startTime = Get-Date

    $fullConfig = Get-Content 
    "C:\Users\jenujenujenu\Documents\PS_Scripts_AWS\AWS_Actions_Git\
    AWS Basic Automation\examples\input\LoadBalancer\ParameterJSON_min_LB.json"

    if ($fullConfig) {
		$Config = [PSObject] ($fullConfig | ConvertFrom-Json)
		$LBcount = $Config.LoadBalancers.length #LB counter
	} else {
		$LBcount = 1
	}
	"$LBcount LoadBalancer(s) to remove"

    #Import-Module AWSPowerShell
    #$ServiceProfile "acpauto"
    #Set-AWSCredential -ProfileName $ServiceProfile

    #Remove LoadBalancers
    #CAUTION: Will remove all attched Listeners too

    for ($i=0; $i -lt $LBcount; $i++){
        if ($fullConfig) {
          if ($null -ne $Config.LoadBalancers[$i].Customer) {
                $Customer = $Config.LoadBalancers[$i].Customer
            }
            if ($null -ne $Config.LoadBalancers[$i].Location) {
                $Region = $Config.LoadBalancers[$i].Location
            }
            if ($null -ne $Config.LoadBalancers[$i].LBName) {
                $LBName = $Config.LoadBalancers[$i].LBName
            }
        }

        $ELB2LBObj = Get-ELB2LoadBalancer -Name $LBName -Region $Region
        Remove-ELB2LoadBalancer -LoadBalancerArn $ELB2LBObj.LoadBalancerArn -Force
        $endTime = Get-Date

        $msg = 'Removal of the LoadBalancer {0} for customer {1}
        has been completed with start time {2} and end time {3}' 
        -f $ELB2LBObj.LoadBalancerName, $Customer, $startTime, $endTime

        Write-Output $msg

        #Remove Listeners

        $startTime = Get-Date

        if ($fullConfig) {
            $Config = [PSObject] ($fullConfig | ConvertFrom-Json)
            $LIScount = $Config.LoadBalancers[$i].Listeners.length
        } else {
            $LIScount = 1
        }
        "$LIScount Listener(s) to remove"

        for ($j = 0; $j -lt $LIScount; $j++) {
            if ($null -ne $Config.LoadBalancers[$i].LBName){
                $LBName = $Config.LoadBalancers[$i].LBName
            }
            if ($null -ne $Config.LoadBalancers[$i].Listeners[$j].Port) {
                $Port = $Config.LoadBalancers[$i].Listeners[$j].Port
            }
        
            #Get all Listeners from specified LoadBalancer
            $LoadBalancerArn =(Get-ELB2LoadBalancer -Name $LBName -Region $Region).LoadBalancerArn
            $ELB2LisObj=Get-ELB2Listener -LoadBalancerArn $LoadBalancerArn

            #Filter Listeners with Port number
            Remove-ELB2Listener -ListenerArn $ELB2LisObj.where({ ($_).Port -eq $Port }).ListenerArn -Force
        
            $endTime = Get-Date

            $msg = 'Removal of the Listener {0} for customer {1} 
            has been completed with start time {2} and end time {3}' 
            -f $ELB2LisObj.where({ ($_).Port -eq $Port }).ListenerArn, $Customer, $startTime, $endTime

            Write-Output $msg
        }

        #Remove TargetGroups
        $startTime = Get-Date

        if ($fullConfig) {
            $Config = [PSObject] ($fullConfig | ConvertFrom-Json)
            $TGcount = $Config.LoadBalancers[$i].TargetGroups.length #TG counter
        } else {
            $TGcount = 1
        }
        "$TGcount TargetGroup(s) to remove"

        for ($k=0; $k -lt $TGcount; $k++){
            if ($fullConfig) {
                if ($null -ne $Config.LoadBalancers[$i].TargetGroups[$k].TGName) {
                    $TGName = $Config.LoadBalancers[$i].TargetGroups[$k].TGName
                }
            }
            
           #Check TG for attached Listeners before deletion
            $ELB2TGObj=Get-ELB2TargetGroup -Name $TGName -Region $Region
            if ($null -ne $ELB2TGObj.LoadBalancerArns) {
                $LBName=
                (Get-ELB2LoadBalancer -LoadBalancerArn $ELB2TGObj.LoadBalancerArns).LoadBalancerName
                'LoadBalancer(s) {0} is/are still attached to TargetGroup {1}.
                Remove LB/Listener forwarding to TG first' 
                -f $LBName, $ELB2TGObj.TargetGroupName
                exit
            }

            Remove-ELB2TargetGroup -TargetGroupArn $ELB2TGObj.TargetGroupArn -Force
            
            $endTime = Get-Date
            $msg = 'Removal of the TargetGroup {0} for customer {1}
             has been completed with start time {2} and end time {3}' 
             -f $TGName, $Customer, $startTime, $endTime
            Write-Output $msg

        }
    }
}
```

### Register Target to Target Group

```{.Atos.Cloud.AWS.Loadbalancer.RegisterT2TG .numberLines startFrom=1}

<#
.SYNOPSIS
.DESCRIPTION
    Please read the full Description first before using this PS script file.
    This PS script registers the specified targets with the specified target group.
    Features:
        - JSON input parameters
            - Requires following input parameters
                - TargetGroup Region [string]
                - TargetGroup Name [string]
                 - Instance Name Tags [Key:"Name"; Value:string] 
        - Target must be in running state before registering
        - Default routing via protocol and port of TargetGroup
            - Override port, when registering if necessary
        - You can register each EC2 instance or IP address with
        the same target group multiple times using different ports
        - With a Network Load Balancer, you cannot register instances 
        by instance ID if they have the following instance types: 
        C1, CC1, CC2, CG1, CG2, CR1, CS1, G1, G2, HI1, HS1, M1, M2, M3, and T1.
            - You can register instances of these types by IP address.
            - Currently not supporting Network Load Balancer
Source:
https://docs.aws.amazon.com/powershell/latest/reference/items/Register-ELB2Target.html
.EXAMPLE
.NOTES
    File Name      : Atos.Cloud.AWS.Loadbalancer.Create
    Author         : Jenusan Baskaran
    Prerequisite   : PowerShell 5.1
    Version        : 20220322
#>

Param(
    #[Parameter(Mandatory)] [string] $fullConfig

)
Process{
    $startTime = Get-Date
    
    $fullConfig = Get-Content 
    "C:\Users\jenujenujenu\Documents\PS_Scripts_AWS\AWS_Actions_Git\
    AWS Basic Automation\examples\input\LoadBalancer\ParameterJSON_min_LB.json"

    <#
    Import-Module AWSPowerShell
    $ServiceProfile "acpauto"
    Set-AWSCredential -ProfileName $ServiceProfile
    #>
    
    if ($fullConfig) {
		$Config = [PSObject] ($fullConfig | ConvertFrom-Json)
		$LBcount = $Config.LoadBalancers.length #LB counter
	} else {
		$LBcount = 1
	}
	

	# Loop through LB Array from JSON input
	for ($i=0; $i -lt $LBcount; $i++){

        if ($fullConfig) {
            $Config = [PSObject] ($fullConfig | ConvertFrom-Json)
            $TGcount = $Config.LoadBalancers[$i].TargetGroups.length #TG counter
        } else {
            $TGcount = 1
        }

        for($j=0; $j -lt $TGcount; $j++){
            if ($fullConfig) {
			    if($null -ne $Config.Customer){
				    $Customer = $Config.Customer[$i]
			    }
			    if ($null -ne $Config.LoadBalancers[$i].Location) {
				    $Region = $Config.LoadBalancers[$i].Location
			    }
                if ($null -ne $Config.LoadBalancers[$i].TargetGroups[$j].TGName) {
                    $TGName = $Config.LoadBalancers[$i].TargetGroups[$j].TGName
                }
                if ($null -ne $Config.LoadBalancers[$i].Servers.Tags) {
                    $tagobject = $Config.LoadBalancers[$i].Servers.Tags
                }
        }

            $ELB2TGObj = Get-ELB2TargetGroup -Region $Region -Name $TGName
            $TargetGroupArn = $ELB2TGObj.TargetGroupArn
            
            if ($tagobject) {
                foreach ($element in $tagobject) {
                    #$element = $element.Replace(" ","-") # don't allow spaces in tags
                    $tag= @{ Key=$element.Key; Value=$element.Value}
                }
            }
        
    
            $instanceID=(Get-EC2Instance 
            -Region $Region 
            -Filter @{Name="tag:Name"; Values=$tag.Value }).Instances.instanceID

            $TargetDescriptionObject = 
            New-Object Amazon.ElasticLoadBalancingV2.Model.TargetDescription

            $TargetDescriptionObject.Id = $instanceID

            Register-ELB2Target -TargetGroupArn $TargetGroupArn -Target $TargetDescriptionObject

            $endTime = Get-Date

            $msg = 'Registration of Target {0} to TargetGroup {1} for customer {2}
             has been completed with start time {3} and end time {4}'
              -f $Target, $TargetGroupArn, $Customer, $startTime, $endTime
            
            Write-Output $msg
        }
    }
}
```

### Deregister Target from Target Group

```{.Atos.Cloud.AWS.Loadbalancer.DeregisterTFromTG .numberLines startFrom=1}
<#
.SYNOPSIS
.DESCRIPTION
    Please read the full Description first before using this PS script file.
    This script deregisters the specified targets from the specified target group.
    Features:
        - JSON input parameters
            - Requires following input parameters:
                - TargetGroup Region [string]
                - TargetGroup Name [string]
                - Server Name Tags [Key:"Name"; Value:string] 
        - Deregister Target from TargetGroups
        - After the targets are deregistered, they no longer receive traffic from the load balancer.
    Future implementation plans:
        - Add Error Handling
Source:
https://docs.aws.amazon.com/powershell/latest/reference/items/Unregister-ELB2Target.html
.EXAMPLE
.\Atos.Cloud.AWS.LoadBalancer.DeregisterTfromTG.ps1 
-Customer ACP-Dev-JB 
-Region eu-west-1 
-TargetGroupArn $TGARN 
-Target $Target
.NOTES
    File Name      : Atos.Cloud.AWS.Loadbalancer.DeregisterTfromTG
    Author         : Jenusan Baskaran
    Prerequisite   : PowerShell 5.1s
    Version        : 20220322
#>
Param(
    #[Parameter(Mandatory)] [string] $fullConfig
)

Process{

    $startTime = Get-Date
    
    $fullConfig = Get-Content 
    "C:\Users\jenujenujenu\Documents\PS_Scripts_AWS\AWS_Actions_Git\
    AWS Basic Automation\examples\input\LoadBalancer\ParameterJSON_min_LB.json"

    #Import-Module AWSPowerShell
    #$ServiceProfile "acpauto"
    #Set-AWSCredential -ProfileName $ServiceProfile

    if ($fullConfig) {
		$Config = [PSObject] ($fullConfig | ConvertFrom-Json)
		$LBcount = $Config.LoadBalancers.length #LB counter
	} else {
		$LBcount = 1
	}

    for ($i = 0; $i -lt $LBcount; $i++) {

        if ($fullConfig) {
            $Config = [PSObject] ($fullConfig | ConvertFrom-Json)
            $TGcount = $Config.LoadBalancers[$i].TargetGroups.length #TG counter
        } else {
            $TGcount = 1
        }

		for($j=0; $j -lt $TGcount; $j++){
            if ($fullConfig) {
			    if($null -ne $Config.Customer){
				    $Customer = $Config.Customer[$i]
			    }
			    if ($null -ne $Config.LoadBalancers[$i].Location) {
				    $Region = $Config.LoadBalancers[$i].Location
			    }
                if ($null -ne $Config.LoadBalancers[$i].TargetGroups[$j].TGName) {
                    $TGName = $Config.LoadBalancers[$i].TargetGroups[$j].TGName
                }
                if ($null -ne $Config.LoadBalancers[$i].Servers.Tags) {
                    $tagobject = $Config.LoadBalancers[$i].Servers.Tags
                }
        }
            $ELB2TGObj = Get-ELB2TargetGroup -Region $Region -Name $TGName
            $TargetGroupArn=$ELB2TGObj.TargetGroupArn

            if ($tagobject) {
                foreach ($element in $tagobject) {
                    #$element = $element.Replace(" ","-") # don't allow spaces in tags
                    $tag= @{ Key=$element.Key; Value=$element.Value}
                }
            }

            $instanceID=(Get-EC2Instance 
            -Region $Region 
            -Filter @{Name="tag:Name"; Values=$tag.Value }).Instances.instanceID

            $TargetDescriptionObject = New-Object Amazon.ElasticLoadBalancingV2.Model.TargetDescription
            $TargetDescriptionObject.Id = $instanceID

            Unregister-ELB2Target -TargetGroupArn $TargetGroupArn -Target $TargetDescriptionObject
        
            $endTime = Get-Date
        
            $msg = 'Deregistration of Target {0} from TargetGroup {1} for customer {2}
             has been completed with start time {3} and end time {4}' 
             -f $Target, $TargetGroupArn, $Customer, $startTime, $endTime

            Write-Output $msg
        }
    }
}
```

## Feedbackbogen

![Feedback1](FB/Feedback_zur_Praxisausbildung-001.jpg){#fig:Feedback1}


![Feedback2](FB/Feedback_zur_Praxisausbildung-002.jpg){#fig:Feedback2}


![Feedback3](FB/Feedback_zur_Praxisausbildung-003.jpg){#fig:Feedback3}


![Feedback4](FB/Feedback_zur_Praxisausbildung-004.jpg){#fig:Feedback4}

